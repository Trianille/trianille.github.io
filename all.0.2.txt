// Глобальные переменные состояния
let currentUser = null;
let currentNoteId = null;
let unsubscribeNotes = null;
let unsubscribeTags = null;
let currentFilterTag = null;
let selectedColor = '#FF6B6B';
let allTags = []; // ГАРАНТИРУЕМ, что это массив
let selectedNoteTags = [];
let selectedRating = 0;
let isOnline = navigator.onLine;
let syncInProgress = false;
let appInitialized = false;

// Инициализация при загрузке
document.addEventListener('DOMContentLoaded', () => {
    console.log('Приложение инициализируется');
    
    // Аварийный таймаут - скрываем загрузку через 5 секунд в любом случае
    setTimeout(() => {
        if (!appInitialized) {
            console.warn('Аварийное скрытие загрузки по таймауту');
            hideLoadingForce();
            showAuthModal(); // Показываем форму авторизации
        }
    }, 5000);
    
    // Настройка Firebase авторизации
    if (auth && typeof auth.onAuthStateChanged === 'function') {
        auth.onAuthStateChanged(handleAuthStateChanged);
    } else {
        console.error('Firebase auth не инициализирован');
        hideLoadingForce();
        showAuthModal();
    }
    
    // Настройка UI
    if (typeof setupColorPicker === 'function') {
        setupColorPicker();
    }
    
    if (typeof setupModalCloseListeners === 'function') {
        setupModalCloseListeners();
    }
    
    // Настройка слушателей сети
    window.addEventListener('online', () => {
        isOnline = true;
        updateNetworkStatus();
    });
    
    window.addEventListener('offline', () => {
        isOnline = false;
        updateNetworkStatus();
    });
    
    // Инициализация модулей (не блокирующая)
    setTimeout(() => {
        initModules();
    }, 100);
});

// Инициализация модулей
function initModules() {
    console.log('Инициализация модулей...');
    
    try {
        if (typeof initAuthModule === 'function') initAuthModule();
        if (typeof initNotesModule === 'function') initNotesModule();
        if (typeof initTagsModule === 'function') initTagsModule();
        if (typeof initUIModule === 'function') initUIModule();
        if (typeof initImportExportModule === 'function') initImportExportModule();
        if (typeof initSettingsModule === 'function') initSettingsModule();
        if (typeof initSyncModule === 'function') initSyncModule();
        
        console.log('Все модули инициализированы');
    } catch (error) {
        console.error('Ошибка инициализации модулей:', error);
    }
}


// ФИКС: Упрощенная обработка авторизации
async function handleAuthStateChanged(user) {
    console.log('Состояние авторизации изменено:', user?.email);
    
    appInitialized = true;
    currentUser = user;
    
    // Всегда скрываем спинер
    hideLoadingForce();
    
    if (user) {
        // ПОКАЗЫВАЕМ ПРИЛОЖЕНИЕ СРАЗУ
        showMainAppImmediate(user);
        
        // Загружаем данные в фоне (не блокируем UI)
        setTimeout(() => {
            loadInitialData(user);
        }, 300);
        
    } else {
        // ПОКАЗЫВАЕМ ФОРМУ АВТОРИЗАЦИИ
        hideMainAppImmediate();
        showAuthModalImmediate();
    }
}

// ФИКС: Немедленный показ приложения (без ожидания данных)
function showMainAppImmediate(user) {
    console.log('Немедленный показ приложения');
    
    // 1. Скрываем всё что не нужно
    const loading = document.getElementById('loading');
    const authModal = document.getElementById('authModal');
    
    if (loading) loading.style.display = 'none';
    if (authModal) authModal.style.display = 'none';
    
    // 2. Показываем основные элементы
    const header = document.getElementById('header');
    const main = document.getElementById('main');
    
    if (header) header.style.display = 'flex';
    if (main) main.style.display = 'block';
    
    // 3. Настраиваем пользовательскую информацию
    try {
        const mainEmail = user.email;
        
        // Аватар
        const avatar = generateAvatar(mainEmail);
        const avatarContainer = document.getElementById('avatarContainer');
        const avatarContainerOptions = document.getElementById('avatarContainerOptions');
        
        if (avatarContainer) {
            avatarContainer.innerHTML = '';
            avatarContainer.appendChild(avatar);
        }
        
        if (avatarContainerOptions) {
            avatarContainerOptions.innerHTML = '';
            avatarContainerOptions.appendChild(avatar.cloneNode(true));
        }
        
        // Email
        const userEmailElement = document.getElementById('userEmail');
        const userEmailOptionsElement = document.getElementById('userEmailOptions');
        
        if (userEmailElement) userEmailElement.textContent = mainEmail;
        if (userEmailOptionsElement) userEmailOptionsElement.textContent = mainEmail;
        
    } catch (error) {
        console.error('Ошибка настройки пользовательской информации:', error);
    }
    
    // 4. Показываем пустой контейнер заметок
    const notesContainer = document.getElementById('notesContainer');
    if (notesContainer && notesContainer.innerHTML === '') {
        notesContainer.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; color: #999; padding: 48px;">
                <div class="spinner small"></div>
                <div style="margin-top: 16px;">Загрузка заметок...</div>
            </div>
        `;
    }
    
    console.log('Приложение показано');
}

// ФИКС: Немедленное скрытие приложения
function hideMainAppImmediate() {
    console.log('Немедленное скрытие приложения');
    
    const header = document.getElementById('header');
    const main = document.getElementById('main');
    
    if (header) header.style.display = 'none';
    if (main) main.style.display = 'none';
    
    // Очищаем контейнер заметок
    const notesContainer = document.getElementById('notesContainer');
    if (notesContainer) {
        notesContainer.innerHTML = '';
    }
    
    // Отписываемся от слушателей
    const state = window.appState;
    if (state) {
        if (state.unsubscribeNotes) {
            state.unsubscribeNotes();
            state.setUnsubscribeNotes(null);
        }
        
        if (state.unsubscribeTags) {
            state.unsubscribeTags();
            state.setUnsubscribeTags(null);
        }
        
        state.setAllTags([]);
        state.setSelectedNoteTags([]);
    }
}

// ФИКС: Немедленный показ формы авторизации
function showAuthModalImmediate() {
    console.log('Немедленный показ формы авторизации');
    
    const loading = document.getElementById('loading');
    const authModal = document.getElementById('authModal');
    
    if (loading) loading.style.display = 'none';
    if (authModal) authModal.style.display = 'flex';
}

// ФИКС: Принудительное скрытие загрузки
function hideLoadingForce() {
    console.log('Принудительное скрытие загрузки');
    
    const loading = document.getElementById('loading');
    if (loading) {
        loading.style.display = 'none';
        loading.classList.add('hidden');
    }
    
    // Также показываем body
    document.body.style.visibility = 'visible';
    document.body.style.opacity = '1';
}

// Загрузка начальных данных (в фоне)
async function loadInitialData(user) {
    console.log('Начинаем загрузку данных в фоне...');
    
    try {
        // 1. Пытаемся загрузить локальные данные
        const localNotes = localStorageManager.loadLocalData(user.uid, 'notes') || [];
        const localTags = localStorageManager.loadLocalData(user.uid, 'tags') || [];
        
        console.log('Локальные данные загружены:', {
            notes: localNotes.length,
            tags: localTags.length
        });
        
        // 2. Сразу показываем локальные данные
        const state = window.appState;
        if (state) {
            state.setAllTags(localTags);
        }
        
        if (localNotes.length > 0 && window.renderNotes) {
            renderNotes(localNotes);
        } else if (localNotes.length === 0) {
            // Показываем пустое состояние
            const notesContainer = document.getElementById('notesContainer');
            if (notesContainer) {
                notesContainer.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; color: #999; padding: 48px;">
                        Нет заметок. Создайте первую!
                    </div>
                `;
            }
        }
        
        // 3. В фоне синхронизируем с Firebase
        if (isOnline) {
            setTimeout(() => {
                backgroundSync();
            }, 2000);
        }
        
    } catch (error) {
        console.error('Ошибка загрузки начальных данных:', error);
        // Не прерываем работу приложения
    }
}


// ФИКС: Быстрая загрузка начальных данных
async function loadInitialData(user) {
    try {
        // 1. Пытаемся загрузить локальные данные (быстро)
        const localNotes = localStorageManager.loadLocalData(user.uid, 'notes') || [];
        const localTags = localStorageManager.loadLocalData(user.uid, 'tags') || [];
        
        // 2. Сразу показываем локальные данные
        window.appState.setAllTags(localTags);
        renderNotes(localNotes);
        
        console.log('Локальные данные загружены:', {
            notes: localNotes.length,
            tags: localTags.length
        });
        
        // 3. В фоне загружаем свежие данные с сервера
        if (isOnline) {
            setTimeout(() => {
                backgroundSync();
            }, 1000); // Даем время отрисовать UI
        }
        
        // 4. Настраиваем фоновые обновления
        setupBackgroundListeners(user);
        
    } catch (error) {
        console.error('Ошибка загрузки данных:', error);
        // Продолжаем работу с пустыми данными
    }
}

// ФИКС: Упрощенная фоновая синхронизация
async function backgroundSync() {
    if (!currentUser || !isOnline || syncInProgress) return;
    
    syncInProgress = true;
    
    try {
        await loadDataFromFirebase();
        await applyPendingChanges();
        console.log('Фоновая синхронизация завершена');
    } catch (error) {
        console.error('Ошибка фоновой синхронизации:', error);
    } finally {
        syncInProgress = false;
    }
}

// ФИКС: Упрощенная загрузка данных
async function loadDataFromFirebase() {
    const state = window.appState;
    
    if (!currentUser) return;
    
    try {
        // Загружаем теги
        const tagsSnapshot = await state.db.collection('users').doc(currentUser.uid)
            .collection('tags')
            .orderBy('name')
            .get();
        
        const tags = [];
        tagsSnapshot.forEach(doc => {
            const data = doc.data();
            tags.push({
                id: doc.id,
                ...data,
                // Конвертируем Firebase Timestamp
                createdAt: data.createdAt ? data.createdAt.toDate ? data.createdAt.toDate() : data.createdAt : null
            });
        });
        
        // Загружаем заметки
        const notesSnapshot = await state.db.collection('users').doc(currentUser.uid)
            .collection('notes')
            .orderBy('updatedAt', 'desc')
            .limit(100)
            .get();
        
        const notes = [];
        notesSnapshot.forEach(doc => {
            const data = doc.data();
            notes.push({
                id: doc.id,
                ...data,
                rating: typeof data.rating === 'number' ? data.rating : 0,
                // Конвертируем Firebase Timestamps
                createdAt: data.createdAt ? data.createdAt.toDate ? data.createdAt.toDate() : data.createdAt : null,
                updatedAt: data.updatedAt ? data.updatedAt.toDate ? data.updatedAt.toDate() : data.updatedAt : null
            });
        });
        
        // Сохраняем локально с помощью менеджера
        localStorageManager.saveOfflineData(currentUser.uid, notes, tags);
        
        // Обновляем UI
        state.setAllTags(tags);
        applyCurrentFilter();
        
        console.log('Данные Firebase загружены:', {
            notes: notes.length,
            tags: tags.length
        });
        
    } catch (error) {
        console.error('Ошибка загрузки из Firebase:', error);
        throw error;
    }
}

// ФИКС: Настройка фоновых слушателей
function setupBackgroundListeners(user) {
    const state = window.appState;
    
    if (!user || !isOnline) return;
    
    // Отписываемся от старых слушателей
    if (unsubscribeNotes) unsubscribeNotes();
    if (unsubscribeTags) unsubscribeTags();
    
    // Слушатель для тегов (только изменения)
    unsubscribeTags = state.db.collection('users').doc(user.uid)
        .collection('tags')
        .onSnapshot((snapshot) => {
            if (!snapshot.empty && snapshot.docChanges().some(change => change.type !== 'metadata')) {
                console.log('Обнаружены изменения тегов');
                setTimeout(() => backgroundSync(), 2000);
            }
        });
    
    // Слушатель для заметок (только последние изменения)
    unsubscribeNotes = state.db.collection('users').doc(user.uid)
        .collection('notes')
        .orderBy('updatedAt', 'desc')
        .limit(1)
        .onSnapshot((snapshot) => {
            if (!snapshot.empty) {
                console.log('Обнаружены изменения заметок');
                setTimeout(() => backgroundSync(), 2000);
            }
        });
}

// ФИКС: Обновление статуса сети
function updateNetworkStatus() {
    const indicator = document.getElementById('networkStatus');
    if (!indicator) return;
    
    if (isOnline) {
        indicator.innerHTML = '<i class="fas fa-wifi"></i>';
        indicator.style.color = '#4CAF50';
        indicator.title = 'Онлайн';
    } else {
        indicator.innerHTML = '<i class="fas fa-wifi-slash"></i>';
        indicator.style.color = '#f44336';
        indicator.title = 'Офлайн';
    }
}

// ФИКС: Упрощенная функция показа приложения
function showMainApp(user) {
    console.log('Показываем основное приложение для:', user.email);
    
    // Скрываем загрузку
    hideLoading();
    
    // Показываем основные элементы
    document.getElementById('header').style.display = 'flex';
    document.getElementById('main').style.display = 'block';
    
    // Настраиваем аватар и email
    const mainEmail = user.email;
    const avatar = generateAvatar(mainEmail);
    
    const avatarContainer = document.getElementById('avatarContainer');
    const avatarContainerOptions = document.getElementById('avatarContainerOptions');
    
    if (avatarContainer) {
        avatarContainer.innerHTML = '';
        avatarContainer.appendChild(avatar);
    }
    
    if (avatarContainerOptions) {
        avatarContainerOptions.innerHTML = '';
        avatarContainerOptions.appendChild(avatar.cloneNode(true));
    }
    
    const userEmailElement = document.getElementById('userEmail');
    const userEmailOptionsElement = document.getElementById('userEmailOptions');
    
    if (userEmailElement) userEmailElement.textContent = mainEmail;
    if (userEmailOptionsElement) userEmailOptionsElement.textContent = mainEmail;
    
    // Скрываем модальное окно авторизации
    document.getElementById('authModal').style.display = 'none';
}

// ФИКС: Улучшенная функция скрытия загрузки
function hideLoading() {
    const loadingElement = document.getElementById('loading');
    if (loadingElement) {
        loadingElement.style.display = 'none';
    }
}

// Настройка выбора цвета
function setupColorPicker() {
    const colorOptions = document.querySelectorAll('.color-option');
    if (colorOptions.length === 0) {
        console.warn('Элементы color-option не найдены');
        return;
    }
    
    colorOptions.forEach(option => {
        option.addEventListener('click', function() {
            colorOptions.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            selectedColor = this.dataset.color;
        });
    });
    
    // Выбираем первый цвет по умолчанию
    if (colorOptions.length > 0) {
        colorOptions[0].classList.add('selected');
        selectedColor = colorOptions[0].dataset.color || '#FF6B6B';
    }
}

// Настройка закрытия модальных окон
function setupModalCloseListeners() {
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeAllModals();
    });
}

// Закрыть все модальные окна
function closeAllModals() {
    const modals = ['authModal', 'noteModal', 'tagsModal', 'addTagModal', 
                   'confirmPopup', 'alertPopup', 'importModal', 'exportModal',
                   'settingsModal'];
    
    modals.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
        }
    });
    
    document.body.style.overflow = 'auto';
}

// Закрытие по клику вне области
function closeModalOnOutsideClick(event, modalId) {
    if (event.target.id === modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }
    }
}

// Применить ожидающие изменения (добавляем эту функцию)
async function applyPendingChanges() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser || !isOnline) return true;
    
    const pendingChanges = localStorageManager.getPendingChanges(currentUser.uid);
    if (pendingChanges.length === 0) return true;
    
    console.log(`Применение ${pendingChanges.length} ожидающих изменений...`);
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const change of pendingChanges) {
        try {
            switch (change.type) {
                case 'CREATE_NOTE':
                    await syncNoteToFirebase(change.data, change.data.id, false);
                    break;
                case 'UPDATE_NOTE':
                    await syncNoteToFirebase(change.data, change.data.id, true);
                    break;
                case 'DELETE_NOTE':
                    await deleteNoteFromFirebase(change.data.id);
                    break;
                case 'CREATE_TAG':
                    await syncTagToFirebase(change.data, change.data.id, false);
                    break;
                case 'DELETE_TAG':
                    await deleteTagFromFirebase(change.data.id);
                    break;
            }
            
            // Удаляем успешно примененное изменение
            localStorageManager.saveLocalData(currentUser.uid, 'pending_changes', 
                pendingChanges.filter(c => c.id !== change.id));
            
            successCount++;
            
        } catch (error) {
            console.error('Ошибка применения изменения:', error, change);
            errorCount++;
        }
    }
    
    console.log(`Изменения применены: ${successCount} успешно, ${errorCount} с ошибками`);
    return errorCount === 0;
}

// Синхронизировать заметку с Firebase (добавляем)
async function syncNoteToFirebase(noteData, localId, isUpdate) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser || !isOnline) return;
    
    try {
        const firebaseData = {
            title: noteData.title || '',
            body: noteData.body || '',
            subbody: noteData.subbody || '',
            notes: noteData.notes || '',
            rating: noteData.rating || 0,
            tagsArray: noteData.tagsArray || [],
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
            userId: currentUser.uid
        };
        
        if (isUpdate) {
            // Убираем локальный префикс если есть
            const firebaseId = localId.replace('local_', '');
            await state.db.collection('users').doc(currentUser.uid)
                .collection('notes').doc(firebaseId).update(firebaseData);
        } else {
            firebaseData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
            const docRef = await state.db.collection('users').doc(currentUser.uid)
                .collection('notes').add(firebaseData);
            
            // Обновляем локальный ID
            updateLocalNoteId(localId, docRef.id);
        }
        
        console.log('Заметка синхронизирована с Firebase');
        
    } catch (error) {
        console.error('Ошибка синхронизации заметки:', error);
        throw error;
    }
}

// Обновить локальный ID заметки (добавляем)
function updateLocalNoteId(localId, firebaseId) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    const localNotes = localStorageManager.loadLocalData(currentUser.uid, 'notes') || [];
    const updatedNotes = localNotes.map(note => {
        if (note.id === localId) {
            return {
                ...note,
                id: firebaseId,
                isLocal: false
            };
        }
        return note;
    });
    
    localStorageManager.saveLocalData(currentUser.uid, 'notes', updatedNotes);
}

// Удалить заметку из Firebase (добавляем)
async function deleteNoteFromFirebase(noteId) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser || !isOnline) return;
    
    try {
        // Удаляем локальный префикс если есть
        const firebaseId = noteId.replace('local_', '');
        
        await state.db.collection('users').doc(currentUser.uid)
            .collection('notes').doc(firebaseId).delete();
        
        console.log('Заметка удалена из Firebase');
        
    } catch (error) {
        console.error('Ошибка удаления заметки из Firebase:', error);
        throw error;
    }
}

// Синхронизировать тег с Firebase (добавляем)
async function syncTagToFirebase(tagData, localId, isUpdate) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser || !isOnline) return;
    
    try {
        const firebaseData = {
            name: tagData.name,
            color: tagData.color,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            userId: currentUser.uid
        };
        
        if (isUpdate) {
            const firebaseId = tagData.id.replace('local_', '');
            await state.db.collection('users').doc(currentUser.uid)
                .collection('tags').doc(firebaseId).update(firebaseData);
        } else {
            const docRef = await state.db.collection('users').doc(currentUser.uid)
                .collection('tags').add(firebaseData);
            
            // Обновляем локальный ID
            updateLocalTagId(localId, docRef.id);
        }
        
        console.log('Тег синхронизирован с Firebase');
        
    } catch (error) {
        console.error('Ошибка синхронизации тега:', error);
        throw error;
    }
}

// Обновить локальный ID тега (добавляем)
function updateLocalTagId(localId, firebaseId) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    const localTags = localStorageManager.loadLocalData(currentUser.uid, 'tags') || [];
    const updatedTags = localTags.map(tag => {
        if (tag.id === localId) {
            return {
                ...tag,
                id: firebaseId,
                isLocal: false
            };
        }
        return tag;
    });
    
    localStorageManager.saveLocalData(currentUser.uid, 'tags', updatedTags);
    state.setAllTags(updatedTags);
}

// Удалить тег из Firebase (добавляем)
async function deleteTagFromFirebase(tagId) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser || !isOnline) return;
    
    try {
        const firebaseId = tagId.replace('local_', '');
        
        await state.db.collection('users').doc(currentUser.uid)
            .collection('tags').doc(firebaseId).delete();
        
        console.log('Тег удален из Firebase');
        
    } catch (error) {
        console.error('Ошибка удаления тега из Firebase:', error);
        throw error;
    }
}

// Экспорт глобальных переменных
window.appState = {
    getCurrentUser: () => currentUser,
    getCurrentNoteId: () => currentNoteId,
    setCurrentNoteId: (id) => { currentNoteId = id; },
    
    // ГАРАНТИРУЕМ, что allTags всегда массив
    getAllTags: () => {
        if (!Array.isArray(allTags)) {
            console.error('allTags не является массивом, исправляем:', allTags);
            allTags = [];
        }
        return allTags;
    },
    
    setAllTags: (tags) => {
        if (!tags) {
            allTags = [];
        } else if (Array.isArray(tags)) {
            allTags = tags;
        } else if (typeof tags === 'object') {
            // Преобразуем объект в массив
            console.warn('setAllTags: получен объект вместо массива, преобразуем:', tags);
            allTags = Object.values(tags);
        } else {
            console.error('setAllTags: некорректный тип данных:', typeof tags);
            allTags = [];
        }
        console.log('setAllTags: установлено тегов:', allTags.length);
    },
    
    getSelectedNoteTags: () => selectedNoteTags,
    setSelectedNoteTags: (tags) => {
        if (Array.isArray(tags)) {
            selectedNoteTags = tags;
        } else {
            selectedNoteTags = [];
        }
    },
    
    getCurrentFilterTag: () => currentFilterTag,
    setCurrentFilterTag: (tag) => { currentFilterTag = tag; },
    getSelectedColor: () => selectedColor,
    getSelectedRating: () => selectedRating,
    setSelectedRating: (rating) => { selectedRating = parseInt(rating) || 0; },
    isOnline: () => isOnline,
    
    // Firebase
    db,
    auth,
    
    // Локальное хранилище
    localStorageManager,
    
    // Подписки
    unsubscribeNotes,
    unsubscribeTags,
    setUnsubscribeNotes: (fn) => { unsubscribeNotes = fn; },
    setUnsubscribeTags: (fn) => { unsubscribeTags = fn; }
};

// Обновляем applyCurrentFilter
function applyCurrentFilter() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) {
        console.log('applyCurrentFilter: пользователь не авторизован');
        showEmptyNotesState();
        return;
    }
    
    try {
        // Загружаем локальные заметки
        let localNotes = localStorageManager.loadLocalData(currentUser.uid, 'notes');
        
        // ГАРАНТИРУЕМ, что это массив
        if (!localNotes) {
            console.log('applyCurrentFilter: заметки не найдены');
            localNotes = [];
        } else if (!Array.isArray(localNotes)) {
            console.error('applyCurrentFilter: заметки не являются массивом, преобразуем:', typeof localNotes);
            
            if (localNotes && typeof localNotes === 'object') {
                if (Array.isArray(localNotes.notes)) {
                    localNotes = localNotes.notes;
                } else if (Array.isArray(localNotes.data)) {
                    localNotes = localNotes.data;
                } else {
                    localNotes = Object.values(localNotes);
                }
            } else {
                localNotes = [];
            }
        }
        
        console.log('applyCurrentFilter: заметок для фильтрации:', localNotes.length);
        
        // Применяем фильтр
        const filterTag = state.getCurrentFilterTag();
        let filteredNotes = localNotes;
        
        if (filterTag && filterTag.trim() !== '' && Array.isArray(localNotes)) {
            filteredNotes = localNotes.filter(note => 
                note && note.tagsArray && Array.isArray(note.tagsArray) && note.tagsArray.includes(filterTag)
            );
            console.log('applyCurrentFilter: после фильтрации осталось:', filteredNotes.length);
        }
        
        // Рендерим отфильтрованные заметки
        if (window.renderNotes) {
            renderNotes(filteredNotes);
        } else {
            console.error('renderNotes функция не найдена');
            showErrorNotesState('Функция renderNotes не найдена');
        }
        
    } catch (error) {
        console.error('Ошибка в applyCurrentFilter:', error);
        showErrorNotesState(error.message);
    }
}

window.setupColorPicker = setupColorPicker;
window.setupModalCloseListeners = setupModalCloseListeners;
window.closeAllModals = closeAllModals;
window.closeModalOnOutsideClick = closeModalOnOutsideClick;// Модуль авторизации
function initAuthModule() {
    console.log('Модуль авторизации инициализирован');
}

// Вход
async function signIn() {
    const email = document.getElementById('email').value;
    const password = document.getElementById('password').value;
    
    if (!email || !password) {
        showAuthMessage('Введите email и пароль', 'error');
        return;
    }
    
    try {
        showLoading();
        await auth.signInWithEmailAndPassword(email, password);
        // Загрузка скроется автоматически в handleAuthStateChanged
    } catch (error) {
        hideLoadingForce(); // Используем принудительное скрытие
        showAuthMessage(error.message, 'error');
    }
}

// Регистрация
async function signUp() {
    const email = document.getElementById('email').value;
    const password = document.getElementById('password').value;
    
    if (!email || !password) {
        showAuthMessage('Введите email и пароль', 'error');
        return;
    }
    
    try {
        showLoading();
        await auth.createUserWithEmailAndPassword(email, password);
        showAuthMessage('Регистрация успешна!', 'success');
        // Загрузка скроется автоматически
    } catch (error) {
        hideLoadingForce(); // Используем принудительное скрытие
        showAuthMessage(error.message, 'error');
    }
}

// Выход
async function signOut() {
    try {
        // Показываем загрузку на короткое время
        showLoading();
        
        const state = window.appState;
        const user = state.getCurrentUser();
        
        if (user) {
            // Очищаем локальные данные пользователя
            localStorageManager.clearUserData(user.uid);
        }
        
        // Отписываемся от слушателей
        if (state.unsubscribeNotes) {
            state.unsubscribeNotes();
            state.setUnsubscribeNotes(null);
        }
        
        if (state.unsubscribeTags) {
            state.unsubscribeTags();
            state.setUnsubscribeTags(null);
        }
        
        // Выходим из Firebase
        await auth.signOut();
        
        // Немедленно показываем форму авторизации
        setTimeout(() => {
            hideLoadingForce();
            showAuthModalImmediate();
        }, 500);
        
    } catch (error) {
        console.error('Ошибка выхода:', error);
        hideLoadingForce();
        showAuthModalImmediate();
    }
}

// Показать модальное окно авторизации (старая версия для обратной совместимости)
function showAuthModal() {
    hideLoadingForce();
    const authModal = document.getElementById('authModal');
    if (authModal) {
        authModal.style.display = 'flex';
    }
}

// Экспорт функций
window.signIn = signIn;
window.signUp = signUp;
window.signOut = signOut;
window.showAuthModal = showAuthModal;// Конфигурация Firebase - ЗАМЕНИТЕ на свою!
const firebaseConfig = {
    apiKey: "AIzaSyARjHo31bujB14BavNlYaiC4Q4GK7zqEWY",
    authDomain: "webappjp-f68a2.firebaseapp.com",
    projectId: "webappjp-f68a2",
    storageBucket: "webappjp-f68a2.firebasestorage.app",
    messagingSenderId: "404634215374",
    appId: "1:404634215374:web:0ec16a9f5f9c2de726819f",
    measurementId: "G-Q0XZ2MGX9T"
  };

// Инициализация Firebase
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const auth = firebase.auth();// Модуль импорта/экспорта заметок
function initImportExportModule() {
    console.log('Модуль импорта/экспорта инициализирован');
    
    // Настройка обработчиков для импорта
    setupImportHandlers();
}

// Настройка обработчиков импорта
function setupImportHandlers() {
    const importFileInput = document.getElementById('importFile');
    if (importFileInput) {
        importFileInput.addEventListener('change', handleFileSelect);
    }
}

// Обработка выбора файла
function handleFileSelect(event) {
    const file = event.target.files[0];
    const importBtn = document.getElementById('importBtn');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const importPreview = document.getElementById('importPreview');
    const previewContent = document.getElementById('previewContent');
    const totalNotes = document.getElementById('totalNotes');
    
    if (!file) {
        importBtn.disabled = true;
        fileInfo.style.display = 'none';
        importPreview.style.display = 'none';
        return;
    }
    
    // Проверяем расширение файла
    if (!file.name.toLowerCase().endsWith('.json')) {
        showAlert('Пожалуйста, выберите JSON файл');
        importBtn.disabled = true;
        return;
    }
    
    // Показываем информацию о файле
    fileName.textContent = `Файл: ${file.name}`;
    fileSize.textContent = `Размер: ${(file.size / 1024).toFixed(2)} КБ`;
    fileInfo.style.display = 'block';
    
    // Читаем и парсим файл
    const reader = new FileReader();
    
    reader.onload = function(e) {
        try {
            const fileContent = e.target.result;
            const notesData = JSON.parse(fileContent);
            
            // Проверяем структуру данных
            if (!Array.isArray(notesData)) {
                throw new Error('Файл должен содержать массив заметок');
            }
            
            // Проверяем первую заметку на наличие обязательных полей
            if (notesData.length > 0) {
                const sampleNote = notesData[0];
                if (!sampleNote.title && !sampleNote.body && !sampleNote.text) {
                    throw new Error('Неверный формат заметок');
                }
            }
            
            // Сохраняем данные для импорта
            window.importNotesData = notesData;
            
            // Показываем превью
            showImportPreview(notesData);
            
            // Активируем кнопку импорта
            importBtn.disabled = false;
            
        } catch (error) {
            console.error('Ошибка парсинга JSON:', error);
            showAlert(`Ошибка: ${error.message}. Убедитесь, что файл содержит валидный JSON с массивом заметок.`);
            importBtn.disabled = true;
            importPreview.style.display = 'none';
        }
    };
    
    reader.onerror = function() {
        showAlert('Ошибка чтения файла');
        importBtn.disabled = true;
    };
    
    reader.readAsText(file);
}

// Показ превью импорта
function showImportPreview(notesData) {
    const importPreview = document.getElementById('importPreview');
    const previewContent = document.getElementById('previewContent');
    const totalNotes = document.getElementById('totalNotes');
    
    if (notesData.length === 0) {
        importPreview.style.display = 'none';
        return;
    }
    
    // Показываем первые 3 заметки для превью
    const previewNotes = notesData.slice(0, 3);
    
    previewContent.innerHTML = previewNotes.map((note, index) => `
        <div class="preview-note" style="margin-bottom: 10px; padding: 10px; background: #fff; border: 1px solid #eee; border-radius: 4px;">
            <div style="font-weight: 600; margin-bottom: 5px;">
                ${index + 1}. ${note.title || 'Без названия'}
            </div>
            <div style="font-size: 12px; color: #666;">
                ${note.body ? note.body.substring(0, 100) + (note.body.length > 100 ? '...' : '') : ''}
            </div>
            ${note.tagsArray && note.tagsArray.length > 0 ? `
                <div style="margin-top: 5px;">
                    Теги: ${note.tagsArray.join(', ')}
                </div>
            ` : ''}
        </div>
    `).join('');
    
    totalNotes.textContent = `Всего заметок для импорта: ${notesData.length}`;
    importPreview.style.display = 'block';
}

// Показать модальное окно импорта
function showImportNotes() {
    // Сбрасываем форму
    document.getElementById('importFile').value = '';
    document.getElementById('importBtn').disabled = true;
    document.getElementById('fileInfo').style.display = 'none';
    document.getElementById('importPreview').style.display = 'none';
    document.getElementById('importStatus').style.display = 'none';
    document.getElementById('importOverwrite').checked = true;
    
    document.getElementById('importModal').style.display = 'flex';
}

// Закрыть модальное окно импорта
function closeImportModal() {
    document.getElementById('importModal').style.display = 'none';
    // Очищаем данные импорта
    window.importNotesData = null;
}

// Обработка импорта
async function processImport() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    const importNotesData = window.importNotesData;
    const overwrite = document.getElementById('importOverwrite').checked;
    const importStatus = document.getElementById('importStatus');
    
    if (!currentUser || !importNotesData || importNotesData.length === 0) {
        showAlert('Нет данных для импорта');
        return;
    }
    
    try {
        showLoading();
        importStatus.style.display = 'block';
        importStatus.innerHTML = '<div style="color: #2196f3;"><i class="fas fa-spinner fa-spin"></i> Начинаем импорт...</div>';
        
        const importedCount = { success: 0, skipped: 0, error: 0 };
        const errors = [];
        
        // Импортируем заметки по одной
        for (let i = 0; i < importNotesData.length; i++) {
            const noteData = importNotesData[i];
            
            try {
                // Подготавливаем данные для импорта
                const noteToImport = {
                    title: noteData.title || '',
                    body: noteData.body || noteData.text || '',
                    subbody: noteData.subbody || '',
                    notes: noteData.notes || '',
                    tagsArray: noteData.tagsArray || noteData.tags || [],
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    userId: currentUser.uid
                };
                
                // Если есть createdAt и мы не перезаписываем, сохраняем оригинальную дату
                if (noteData.createdAt && !overwrite) {
                    noteToImport.createdAt = noteData.createdAt.toDate ? 
                        noteData.createdAt.toDate() : new Date(noteData.createdAt);
                } else {
                    noteToImport.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                }
                
                // Проверяем, существует ли уже заметка с таким ID
                if (noteData.id && !overwrite) {
                    const existingDoc = await state.db.collection('users').doc(currentUser.uid)
                        .collection('notes').doc(noteData.id).get();
                    
                    if (existingDoc.exists) {
                        importedCount.skipped++;
                        continue;
                    }
                }
                
                // Сохраняем заметку
                if (noteData.id && overwrite) {
                    // Обновляем существующую заметку
                    await state.db.collection('users').doc(currentUser.uid)
                        .collection('notes').doc(noteData.id).set(noteToImport);
                } else {
                    // Создаем новую заметку
                    await state.db.collection('users').doc(currentUser.uid)
                        .collection('notes').add(noteToImport);
                }
                
                importedCount.success++;
                
                // Обновляем статус каждые 10 заметок
                if (i % 10 === 0 || i === importNotesData.length - 1) {
                    importStatus.innerHTML = `
                        <div style="color: #2196f3;">
                            <i class="fas fa-spinner fa-spin"></i> 
                            Импортировано ${i + 1} из ${importNotesData.length} заметок...
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error(`Ошибка импорта заметки ${i}:`, error);
                importedCount.error++;
                errors.push(`Заметка ${i + 1}: ${error.message}`);
                
                // Продолжаем импорт остальных заметок
                continue;
            }
        }
        
        hideLoading();
        
        // Показываем результат
        let statusHtml = `
            <div style="color: #4caf50;">
                <i class="fas fa-check-circle"></i> Импорт завершен!
            </div>
            <div style="margin-top: 10px; font-size: 14px;">
                <div>Успешно: ${importedCount.success}</div>
                <div>Пропущено: ${importedCount.skipped}</div>
                <div>Ошибок: ${importedCount.error}</div>
            </div>
        `;
        
        if (errors.length > 0) {
            statusHtml += `
                <div style="margin-top: 10px; font-size: 12px; color: #f44336;">
                    <strong>Ошибки:</strong><br>
                    ${errors.slice(0, 5).join('<br>')}
                    ${errors.length > 5 ? `<br>... и еще ${errors.length - 5} ошибок` : ''}
                </div>
            `;
        }
        
        importStatus.innerHTML = statusHtml;
        
        // Очищаем данные импорта через 3 секунды
        setTimeout(() => {
            closeImportModal();
        }, 3000);
        
    } catch (error) {
        hideLoading();
        console.error('Ошибка импорта:', error);
        importStatus.innerHTML = `
            <div style="color: #f44336;">
                <i class="fas fa-exclamation-circle"></i> Ошибка импорта: ${error.message}
            </div>
        `;
    }
}

// Показать модальное окно экспорта
async function showExportNotes() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) {
        showAlert('Сначала войдите в систему');
        return;
    }
    
    try {
        showLoading();
        
        // Получаем все заметки пользователя
        const notesQuery = await state.db.collection('users').doc(currentUser.uid)
            .collection('notes')
            .orderBy('updatedAt', 'desc')
            .get();
        
        const notes = [];
        notesQuery.forEach(doc => {
            notes.push({
                id: doc.id,
                ...doc.data()
            });
        });
        
        // Получаем все теги пользователя
        const tagsQuery = await state.db.collection('users').doc(currentUser.uid)
            .collection('tags')
            .get();
        
        const tags = [];
        tagsQuery.forEach(doc => {
            tags.push({
                id: doc.id,
                ...doc.data()
            });
        });
        
        hideLoading();
        
        // Обновляем статистику
        document.getElementById('exportTotalNotesCount').textContent = notes.length;
        document.getElementById('exportNotesWithTags').textContent = notes.filter(n => n.tagsArray && n.tagsArray.length > 0).length;
        document.getElementById('exportTotalTagsCount').textContent = tags.length;
        
        // Сохраняем данные для экспорта
        window.exportNotesData = notes;
        window.exportTagsData = tags;
        
        document.getElementById('exportModal').style.display = 'flex';
        
    } catch (error) {
        hideLoading();
        console.error('Ошибка загрузки данных для экспорта:', error);
        showAlert('Ошибка загрузки данных: ' + error.message);
    }
}

// Закрыть модальное окно экспорта
function closeExportModal() {
    document.getElementById('exportModal').style.display = 'none';
    // Очищаем данные экспорта
    window.exportNotesData = null;
    window.exportTagsData = null;
}

// Экспорт заметок
function exportNotes() {
    const exportNotesData = window.exportNotesData;
    const exportTagsData = window.exportTagsData;
    const exportFormat = document.getElementById('exportFormat').value;
    const withTags = document.getElementById('exportWithTags').checked;
    const withTimestamps = document.getElementById('exportTimestamps').checked;
    const exportStatus = document.getElementById('exportStatus');
    
    if (!exportNotesData || exportNotesData.length === 0) {
        showAlert('Нет заметок для экспорта');
        return;
    }
    
    try {
        exportStatus.style.display = 'block';
        exportStatus.innerHTML = '<div style="color: #2196f3;"><i class="fas fa-spinner fa-spin"></i> Подготовка экспорта...</div>';
        
        // Подготавливаем данные для экспорта
        let dataToExport;
        
        if (withTags) {
            dataToExport = {
                notes: exportNotesData.map(note => {
                    const exportedNote = { ...note };
                    
                    // Очищаем Firebase-specific поля
                    delete exportedNote.userId;
                    
                    if (!withTimestamps) {
                        delete exportedNote.createdAt;
                        delete exportedNote.updatedAt;
                    }
                    
                    // Конвертируем Timestamp в Date если нужно
                    if (withTimestamps) {
                        if (exportedNote.createdAt && exportedNote.createdAt.toDate) {
                            exportedNote.createdAt = exportedNote.createdAt.toDate().toISOString();
                        }
                        if (exportedNote.updatedAt && exportedNote.updatedAt.toDate) {
                            exportedNote.updatedAt = exportedNote.updatedAt.toDate().toISOString();
                        }
                    }
                    
                    return exportedNote;
                }),
                tags: exportTagsData.map(tag => {
                    const exportedTag = { ...tag };
                    delete exportedTag.userId;
                    
                    if (exportedTag.createdAt && exportedTag.createdAt.toDate) {
                        exportedTag.createdAt = exportedTag.createdAt.toDate().toISOString();
                    }
                    
                    return exportedTag;
                }),
                exportInfo: {
                    exportedAt: new Date().toISOString(),
                    totalNotes: exportNotesData.length,
                    totalTags: exportTagsData.length,
                    format: exportFormat,
                    version: '1.0'
                }
            };
        } else {
            dataToExport = exportNotesData.map(note => {
                const exportedNote = { ...note };
                
                // Очищаем Firebase-specific поля
                delete exportedNote.userId;
                
                if (!withTimestamps) {
                    delete exportedNote.createdAt;
                    delete exportedNote.updatedAt;
                }
                
                // Конвертируем Timestamp в Date если нужно
                if (withTimestamps) {
                    if (exportedNote.createdAt && exportedNote.createdAt.toDate) {
                        exportedNote.createdAt = exportedNote.createdAt.toDate().toISOString();
                    }
                    if (exportedNote.updatedAt && exportedNote.updatedAt.toDate) {
                        exportedNote.updatedAt = exportedNote.updatedAt.toDate().toISOString();
                    }
                }
                
                return exportedNote;
            });
        }
        
        // Форматируем JSON
        let jsonString;
        if (exportFormat === 'json_min') {
            jsonString = JSON.stringify(dataToExport);
        } else {
            jsonString = JSON.stringify(dataToExport, null, 2);
        }
        
        // Создаем и скачиваем файл
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `notes_export_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        exportStatus.innerHTML = `
            <div style="color: #4caf50;">
                <i class="fas fa-check-circle"></i> Экспорт завершен! Файл скачан.
            </div>
        `;
        
        // Закрываем окно через 2 секунды
        setTimeout(() => {
            closeExportModal();
        }, 2000);
        
    } catch (error) {
        console.error('Ошибка экспорта:', error);
        exportStatus.innerHTML = `
            <div style="color: #f44336;">
                <i class="fas fa-exclamation-circle"></i> Ошибка экспорта: ${error.message}
            </div>
        `;
    }
}

// Экспорт функций
window.showImportNotes = showImportNotes;
window.showExportNotes = showExportNotes;
window.closeImportModal = closeImportModal;
window.closeExportModal = closeExportModal;
window.processImport = processImport;
window.exportNotes = exportNotes;
window.handleFileSelect = handleFileSelect;// local-storage.js (добавляем функции для работы с датами)
class LocalStorageManager {
    constructor() {
        this.keyPrefix = 'minimal_notes_';
    }

    // Конвертировать данные для сохранения (Firestore Timestamp -> ISO строка)
    prepareDataForStorage(data) {
        if (!data) return data;
        
        if (Array.isArray(data)) {
            return data.map(item => this.convertTimestampsToStrings(item));
        } else if (typeof data === 'object') {
            return this.convertTimestampsToStrings(data);
        }
        
        return data;
    }

    // Конвертировать Timestamp в строку
    convertTimestampsToStrings(obj) {
        if (!obj || typeof obj !== 'object') return obj;
        
        const converted = { ...obj };
        
        for (const key in converted) {
            const value = converted[key];
            
            // Проверяем, является ли это Firebase Timestamp
            if (value && typeof value === 'object') {
                // Проверяем наличие метода toDate (Firebase Timestamp)
                if (value.toDate && typeof value.toDate === 'function') {
                    converted[key] = value.toDate().toISOString();
                }
                // Проверяем, является ли это обычным Date объектом
                else if (value instanceof Date) {
                    converted[key] = value.toISOString();
                }
                // Рекурсивно обрабатываем вложенные объекты
                else if (typeof value === 'object' && !Array.isArray(value)) {
                    converted[key] = this.convertTimestampsToStrings(value);
                }
            }
        }
        
        return converted;
    }

    // Конвертировать строки обратно в Date объекты
    convertStringsToDates(obj) {
        if (!obj || typeof obj !== 'object') return obj;
        
        const converted = { ...obj };
        
        for (const key in converted) {
            const value = converted[key];
            
            if (typeof value === 'string') {
                // Проверяем, является ли это ISO строкой даты
                if (this.isISODateString(value)) {
                    converted[key] = new Date(value);
                }
            }
            // Рекурсивно обрабатываем вложенные объекты
            else if (value && typeof value === 'object' && !Array.isArray(value)) {
                converted[key] = this.convertStringsToDates(value);
            }
        }
        
        return converted;
    }

    // Проверка, является ли строка ISO датой
    isISODateString(str) {
        return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(str);
    }

    // Сохранить данные с конвертацией дат
    saveLocalData(userId, dataType, data) {
        try {
            const key = `${this.keyPrefix}${userId}_${dataType}`;
            const preparedData = this.prepareDataForStorage(data);
            localStorage.setItem(key, JSON.stringify(preparedData));
            return true;
        } catch (error) {
            console.error('Ошибка сохранения в localStorage:', error);
            return false;
        }
    }

    // Загрузить данные с конвертацией дат обратно
    loadLocalData(userId, dataType) {
        try {
            const key = `${this.keyPrefix}${userId}_${dataType}`;
            const data = localStorage.getItem(key);
            
            if (!data) return null;
            
            const parsedData = JSON.parse(data);
            return this.convertStringsToDates(parsedData);
        } catch (error) {
            console.error('Ошибка загрузки из localStorage:', error);
            return null;
        }
    }

    // Сохранить полный набор данных
    saveOfflineData(userId, notes, tags) {
        // Конвертируем и сохраняем заметки
        const preparedNotes = notes.map(note => this.prepareNoteForStorage(note));
        this.saveLocalData(userId, 'notes', preparedNotes);
        
        // Конвертируем и сохраняем теги
        const preparedTags = tags.map(tag => this.prepareTagForStorage(tag));
        this.saveLocalData(userId, 'tags', preparedTags);
        
        // Сохраняем время синхронизации
        this.saveLocalData(userId, 'last_sync', new Date().toISOString());
    }

    // Подготовить заметку для хранения
    prepareNoteForStorage(note) {
        if (!note) return note;
        
        const preparedNote = { ...note };
        
        // Конвертируем даты
        if (preparedNote.createdAt) {
            preparedNote.createdAt = this.convertTimestamp(preparedNote.createdAt);
        }
        
        if (preparedNote.updatedAt) {
            preparedNote.updatedAt = this.convertTimestamp(preparedNote.updatedAt);
        }
        
        return preparedNote;
    }

    // Подготовить тег для хранения
    prepareTagForStorage(tag) {
        if (!tag) return tag;
        
        const preparedTag = { ...tag };
        
        // Конвертируем дату создания
        if (preparedTag.createdAt) {
            preparedTag.createdAt = this.convertTimestamp(preparedTag.createdAt);
        }
        
        return preparedTag;
    }

    // Конвертировать Timestamp в строку
    convertTimestamp(timestamp) {
        if (!timestamp) return null;
        
        // Если это Firebase Timestamp
        if (timestamp.toDate && typeof timestamp.toDate === 'function') {
            return timestamp.toDate().toISOString();
        }
        
        // Если это Date объект
        if (timestamp instanceof Date) {
            return timestamp.toISOString();
        }
        
        // Если это уже строка
        if (typeof timestamp === 'string') {
            return timestamp;
        }
        
        // Если это объект с seconds и nanoseconds (Firestore Timestamp структура)
        if (timestamp.seconds !== undefined) {
            const date = new Date(timestamp.seconds * 1000);
            if (timestamp.nanoseconds) {
                date.setMilliseconds(date.getMilliseconds() + timestamp.nanoseconds / 1000000);
            }
            return date.toISOString();
        }
        
        return null;
    }

    // Получить ожидающие изменения
    getPendingChanges(userId) {
        const changes = this.loadLocalData(userId, 'pending_changes') || [];
        
        // Конвертируем даты в изменениях
        return changes.map(change => {
            const convertedChange = { ...change };
            
            if (convertedChange.timestamp && typeof convertedChange.timestamp === 'string') {
                convertedChange.timestamp = new Date(convertedChange.timestamp);
            }
            
            if (convertedChange.data) {
                convertedChange.data = this.convertStringsToDates(convertedChange.data);
            }
            
            return convertedChange;
        });
    }

    // Добавить изменение в очередь
    addPendingChange(userId, change) {
        const changes = this.getPendingChanges(userId);
        
        // Подготавливаем данные для сохранения
        const preparedChange = {
            id: Date.now() + Math.random().toString(36).substr(2, 9),
            timestamp: new Date().toISOString(), // Сохраняем как строку
            ...change
        };
        
        // Подготавливаем data для сохранения
        if (preparedChange.data) {
            preparedChange.data = this.prepareDataForStorage(preparedChange.data);
        }
        
        changes.push(preparedChange);
        return this.saveLocalData(userId, 'pending_changes', changes);
    }

    // Очистить очередь изменений
    clearPendingChanges(userId) {
        return this.saveLocalData(userId, 'pending_changes', []);
    }

    // Удалить данные пользователя
    clearUserData(userId) {
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith(`${this.keyPrefix}${userId}_`)) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
    }
}

// Создаем глобальный экземпляр
const localStorageManager = new LocalStorageManager();
window.localStorageManager = localStorageManager;// Модуль работы с заметками
function initNotesModule() {
    console.log('Модуль заметок инициализирован');
    setupRatingSelector();
}

// Настройка селектора оценки
function setupRatingSelector() {
    const container = document.getElementById('ratingSelector');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Создаем опции от 0 до 5
    for (let i = 0; i <= 5; i++) {
        const option = document.createElement('div');
        option.className = 'rating-option';
        option.dataset.value = i;
        option.onclick = () => selectRating(i);
        container.appendChild(option);
    }
}

// Выбор оценки
function selectRating(value) {
    const state = window.appState;
    state.setSelectedRating(value);
    
    // Обновляем UI
    document.querySelectorAll('.rating-option').forEach(option => {
        if (parseInt(option.dataset.value) === value) {
            option.classList.add('selected');
        } else {
            option.classList.remove('selected');
        }
    });
}

// Открыть модальное окно заметки
async function openNoteModal(note = null) {
    const state = window.appState;
    
    state.setCurrentNoteId(note ? note.id : null);
    state.setSelectedNoteTags(note ? [...(note.tagsArray || [])] : []);
    
    // Устанавливаем оценку (по умолчанию 0 если не указана)
    const rating = note && typeof note.rating === 'number' ? note.rating : 0;
    state.setSelectedRating(rating);
    
    document.getElementById('modalTitle').textContent = 
        note ? 'Редактировать заметку' : 'Новая заметка';
    document.getElementById('modalNoteTitle').value = note?.title || '';
    document.getElementById('modalNoteBody').value = note?.body || '';
    document.getElementById('modalNoteSubbody').value = note?.subbody || '';
    document.getElementById('modalNoteNotes').value = note?.notes || '';
    
    document.getElementById('deleteNoteBtn').style.display = 
        note ? 'block' : 'none';
    
    // Обновляем список доступных тегов
    if (window.renderAvailableTags) {
        renderAvailableTags();
    }
    
    // Обновляем селектор оценки
    updateRatingSelector(rating);
    
    document.getElementById('noteModal').style.display = 'flex';
}

// Обновить селектор оценки
function updateRatingSelector(rating) {
    document.querySelectorAll('.rating-option').forEach(option => {
        const value = parseInt(option.dataset.value);
        if (value === rating) {
            option.classList.add('selected');
        } else {
            option.classList.remove('selected');
        }
    });
}

// Закрыть модальное окно заметки
function closeNoteModal() {
    document.getElementById('noteModal').style.display = 'none';
    resetNoteForm();
}

// Сброс формы заметки
function resetNoteForm() {
    const state = window.appState;
    
    state.setCurrentNoteId(null);
    state.setSelectedNoteTags([]);
    state.setSelectedRating(0);
    
    document.getElementById('modalNoteTitle').value = '';
    document.getElementById('modalNoteBody').value = '';
    document.getElementById('modalNoteSubbody').value = '';
    document.getElementById('modalNoteNotes').value = '';
    document.getElementById('deleteNoteBtn').style.display = 'none';
    
    // Сброс селектора оценки
    updateRatingSelector(0);
}

// Рендеринг доступных тегов в форме заметки
function renderAvailableTags() {
    const state = window.appState;
    const container = document.getElementById('availableTags');
    const allTags = state.getAllTags();
    const selectedTags = state.getSelectedNoteTags();
    
    if (!container) return;
    
    if (allTags.length === 0) {
        container.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">Нет созданных тегов</div>';
        return;
    }
    
    container.innerHTML = allTags.map(tag => {
        const isSelected = selectedTags.includes(tag.name);
        return `
            <div class="tag-selector-item ${isSelected ? 'selected' : ''}" 
                 style="background: ${tag.color}"
                 onclick="toggleTagSelection('${tag.name}')"
                 title="${tag.name}">
                ${tag.name}
            </div>
        `;
    }).join('');
}

// Переключение выбора тега
function toggleTagSelection(tagName) {
    const state = window.appState;
    let selectedTags = state.getSelectedNoteTags();
    
    if (selectedTags.includes(tagName)) {
        selectedTags = selectedTags.filter(tag => tag !== tagName);
    } else {
        selectedTags.push(tagName);
    }
    
    state.setSelectedNoteTags(selectedTags);
    renderAvailableTags();
}

// Сохранить заметку
async function saveNote() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    const title = document.getElementById('modalNoteTitle').value.trim();
    const body = document.getElementById('modalNoteBody').value.trim();
    const subbody = document.getElementById('modalNoteSubbody').value.trim();
    const notes = document.getElementById('modalNoteNotes').value.trim();
    const rating = state.getSelectedRating() || 0;
    
    if (!title) {
        showAlert('Введите заголовок заметки');
        return;
    }
    
    const noteData = {
        title,
        body,
        subbody,
        notes,
        rating: rating,
        tagsArray: state.getSelectedNoteTags()
    };
    
    try {
        showLoading();
        
        const currentNoteId = state.getCurrentNoteId();
        const isUpdate = !!currentNoteId;
        
        if (isUpdate) {
            noteData.id = currentNoteId;
        }
        
        // Сохраняем локально
        await saveNoteLocally(noteData, isUpdate);
        
        // ОБНОВЛЯЕМ СТАТИСТИКУ ИСПОЛЬЗОВАНИЯ ТЕГОВ
        updateTagUsageCounts();
        
        // Обновляем счетчики
        if (window.updateUserCounters) {
            await updateUserCounters();
        }
        
        hideLoading();
        closeNoteModal();
        showAlert(isUpdate ? 'Заметка обновлена' : 'Заметка создана');
        
    } catch (error) {
        hideLoading();
        console.error('Ошибка сохранения:', error);
        showAlert('Ошибка сохранения: ' + error.message);
    }
}

// Новая функция для обновления статистики использования тегов
async function updateTagUsageCounts() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    // Загружаем текущие заметки и теги
    const localNotes = localStorageManager.loadLocalData(currentUser.uid, 'notes') || [];
    const localTags = localStorageManager.loadLocalData(currentUser.uid, 'tags') || [];
    
    // Считаем использование каждого тега
    const tagUsage = {};
    localNotes.forEach(note => {
        if (note.tagsArray && Array.isArray(note.tagsArray)) {
            note.tagsArray.forEach(tagName => {
                tagUsage[tagName] = (tagUsage[tagName] || 0) + 1;
            });
        }
    });
    
    // Обновляем счетчики в тегах
    const updatedTags = localTags.map(tag => ({
        ...tag,
        usageCount: tagUsage[tag.name] || 0
    }));
    
    // Сохраняем обновленные теги
    localStorageManager.saveLocalData(currentUser.uid, 'tags', updatedTags);
    
    // Обновляем глобальное состояние
    state.setAllTags(updatedTags);
    
    // Обновляем UI тегов если окно тегов открыто
    if (document.getElementById('tagsModal') && 
        document.getElementById('tagsModal').style.display === 'flex') {
        if (window.updateAllTagUIs) {
            updateAllTagUIs();
        }
    }
}

// Сохранить заметку локально
async function saveNoteLocally(noteData, isUpdate = false) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return null;
    
    // Загружаем текущие заметки
    const localNotes = localStorageManager.loadLocalData(currentUser.uid, 'notes') || [];
    let updatedNotes = [...localNotes];
    let noteId = noteData.id;
    
    if (isUpdate && noteId) {
        // Обновление существующей заметки
        const index = updatedNotes.findIndex(n => n.id === noteId);
        if (index !== -1) {
            updatedNotes[index] = {
                ...updatedNotes[index],
                ...noteData,
                updatedAt: new Date() // Используем Date объект
            };
        }
    } else {
        // Создание новой заметки
        noteId = `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newNote = {
            ...noteData,
            id: noteId,
            createdAt: new Date(), // Используем Date объект
            updatedAt: new Date(), // Используем Date объект
            isLocal: true
        };
        updatedNotes.unshift(newNote);
    }
    
    // Сохраняем локально с помощью менеджера
    localStorageManager.saveLocalData(currentUser.uid, 'notes', updatedNotes);
    
    // Добавляем в очередь синхронизации
    if (window.isOnline && isOnline) {
        // Если онлайн, пытаемся сразу синхронизировать
        if (window.syncNoteToFirebase) {
            await syncNoteToFirebase(noteData, noteId, isUpdate);
        }
    } else {
        // Если офлайн, добавляем в очередь
        localStorageManager.addPendingChange(currentUser.uid, {
            type: isUpdate ? 'UPDATE_NOTE' : 'CREATE_NOTE',
            data: { ...noteData, id: noteId },
            timestamp: new Date().toISOString()
        });
    }
    
    // Применяем фильтр и перерисовываем
    if (window.applyCurrentFilter) {
        applyCurrentFilter();
    }
    
    return noteId;
}

// Показать подтверждение удаления заметки
function showDeleteNoteConfirm() {
    showConfirm('Удалить эту заметку?', deleteCurrentNote);
}

// Удалить заметку
async function deleteCurrentNote() {
    const state = window.appState;
    const currentNoteId = state.getCurrentNoteId();
    const currentUser = state.getCurrentUser();
    
    if (!currentNoteId || !currentUser) return;
    
    try {
        showLoading();
        
        // Удаляем локально
        await deleteNoteLocally(currentNoteId);
        
        // Обновляем счетчики
        if (window.updateUserCounters) {
            await updateUserCounters();
        }
        
        hideLoading();
        closeNoteModal();
        showAlert('Заметка удалена');
        
    } catch (error) {
        hideLoading();
        console.error('Ошибка удаления:', error);
        showAlert('Ошибка удаления: ' + error.message);
    }
}

// Удалить заметку локально
async function deleteNoteLocally(noteId) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    // Загружаем текущие заметки
    const localNotes = localStorageManager.loadLocalData(currentUser.uid, 'notes') || [];
    const updatedNotes = localNotes.filter(note => note.id !== noteId);
    
    // Сохраняем локально
    localStorageManager.saveLocalData(currentUser.uid, 'notes', updatedNotes);
    
    // Добавляем в очередь синхронизации
    if (window.isOnline && isOnline) {
        // Если онлайн, пытаемся сразу удалить из Firebase
        if (window.deleteNoteFromFirebase) {
            await deleteNoteFromFirebase(noteId);
        }
    } else {
        // Если офлайн, добавляем в очередь
        localStorageManager.addPendingChange(currentUser.uid, {
            type: 'DELETE_NOTE',
            data: { id: noteId },
            timestamp: new Date().toISOString()
        });
    }
    
    // Применяем фильтр и перерисовываем
    if (window.applyCurrentFilter) {
        applyCurrentFilter();
    }
}

// Экспорт функций В САМОМ КОНЦЕ ФАЙЛА
window.openNoteModal = openNoteModal;
window.closeNoteModal = closeNoteModal;
window.saveNote = saveNote;
window.showDeleteNoteConfirm = showDeleteNoteConfirm;
window.deleteCurrentNote = deleteCurrentNote;
window.toggleTagSelection = toggleTagSelection;
window.selectRating = selectRating;
window.setupRatingSelector = setupRatingSelector;
window.updateRatingSelector = updateRatingSelector;
window.saveNoteLocally = saveNoteLocally;
window.deleteNoteLocally = deleteNoteLocally;
window.renderAvailableTags = renderAvailableTags;
window.updateTagUsageCounts = updateTagUsageCounts;// Инициализация модуля настроек
function initSettingsModule() {
    const settingsBtn = document.getElementById('settingsBtn');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const closeBtn = document.querySelector('.close-btn[data-modal-id="settingsModal"]');
    const cancelBtn = document.querySelector('.btn-secondary[data-modal-id="settingsModal"]');
    
    if (settingsBtn) {
        settingsBtn.addEventListener('click', () => {
            openSettingsModal();
        });
    }
    
    if (saveSettingsBtn) {
        saveSettingsBtn.addEventListener('click', saveSettings);
    }
    
    if (closeBtn) {
        closeBtn.addEventListener('click', () => closeModal('settingsModal'));
    }
    
    if (cancelBtn) {
        cancelBtn.addEventListener('click', () => closeModal('settingsModal'));
    }
}

// Открытие модального окна настроек
async function openSettingsModal() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    try {
        // Загружаем настройки пользователя
        const userDoc = await state.db.collection('users').doc(currentUser.uid).get();
        
        if (userDoc.exists) {
            const userData = userDoc.data();
            console.log(userData);
            // Загружаем статистику
			const notesQuery = userData.totalNotes;
			const tagsQuery = userData.totalTags;
            /*const notesQuery = await state.db.collection('users').doc(currentUser.uid)
                .collection('notes')
                .get();
            
            const tagsQuery = await state.db.collection('users').doc(currentUser.uid)
                .collection('tags')
                .get();
            */
            // Обновляем счетчики в интерфейсе
            document.getElementById('settingsTotalNotesCount').textContent = notesQuery;
            document.getElementById('settingsTotalTagsCount').textContent = tagsQuery;
            
            // Загружаем сохраненные настройки
            const cardsPerSession = userData.cardsPerSession || '20';
            const cardsPerSessionSelect = document.getElementById('cardsPerSessionSelect');
            if (cardsPerSessionSelect) {
                cardsPerSessionSelect.value = cardsPerSession;
            }
        }
        
        openModal('settingsModal');
        
    } catch (error) {
        console.error('Ошибка загрузки настроек:', error);
        showAlert('Ошибка загрузки настроек');
    }
}

// Сохранение настроек
async function saveSettings() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    try {
        const cardsPerSessionSelect = document.getElementById('cardsPerSessionSelect');
        const cardsPerSession = cardsPerSessionSelect ? cardsPerSessionSelect.value : '20';
        
        // Загружаем текущие данные пользователя
        const userDocRef = state.db.collection('users').doc(currentUser.uid);
        const userDoc = await userDocRef.get();
        
        const userData = userDoc.exists ? userDoc.data() : {};
        
        // Обновляем настройки
        const updatedData = {
            ...userData,
            cardsPerSession,
            updatedAt: new Date().toISOString()
        };
        
        await userDocRef.set(updatedData, { merge: true });
        
        showAlert('Настройки сохранены');
        closeModal('settingsModal');
        
    } catch (error) {
        console.error('Ошибка сохранения настроек:', error);
        showAlert('Ошибка сохранения настроек');
    }
}

// Функция для обновления счетчиков в Firestore
async function updateUserCounters() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    try {
        // Получаем текущее количество заметок и тегов
        const notesQuery = await state.db.collection('users').doc(currentUser.uid)
            .collection('notes')
            .get();
        
        const tagsQuery = await state.db.collection('users').doc(currentUser.uid)
            .collection('tags')
            .get();
        
        // Обновляем документ пользователя
        await state.db.collection('users').doc(currentUser.uid).set({
            totalNotes: notesQuery.size,
            totalTags: tagsQuery.size,
            updatedAt: new Date().toISOString()
        }, { merge: true });
        
        console.log('Счетчики обновлены:', {
            notes: notesQuery.size,
            tags: tagsQuery.size
        });
        
    } catch (error) {
        console.error('Ошибка обновления счетчиков:', error);
    }
}

// Функции для обновления счетчиков при изменениях
async function updateNotesCounter() {
    await updateUserCounters();
}

async function updateTagsCounter() {
    await updateUserCounters();
}// sync.js (исправленная версия)
function initSyncModule() {
    console.log('Модуль синхронизации инициализирован');
    
    // Добавляем кнопку синхронизации при загрузке
    setTimeout(() => {
        addSyncButton();
    }, 1000);
}

function addSyncButton() {
    const controlsRight = document.querySelector('.controls-right');
    if (!controlsRight) {
        console.warn('Элемент controls-right не найден');
        return;
    }
    
    // Проверяем, не добавлена ли уже кнопка
    if (document.getElementById('syncBtn')) {
        return;
    }
    
    const syncBtn = document.createElement('button');
    syncBtn.id = 'syncBtn';
    syncBtn.className = 'btn-secondary';
    syncBtn.title = 'Синхронизировать';
    syncBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
    syncBtn.onclick = performManualSync;
    
    const networkIndicator = document.createElement('div');
    networkIndicator.id = 'networkStatus';
    networkIndicator.style.marginLeft = '8px';
    networkIndicator.style.cursor = 'default';
    
    controlsRight.appendChild(syncBtn);
    controlsRight.appendChild(networkIndicator);
    
    // Обновляем статус сети
    if (window.updateNetworkStatus) {
        window.updateNetworkStatus();
    }
}

async function performManualSync() {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) {
        showAlert('Сначала войдите в систему');
        return;
    }
    
    if (!state.isOnline()) {
        showAlert('Нет подключения к интернету');
        return;
    }
    
    const syncBtn = document.getElementById('syncBtn');
    const originalHtml = syncBtn ? syncBtn.innerHTML : '';
    
    if (syncBtn) {
        syncBtn.disabled = true;
        syncBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    }
    
    try {
        showLoading();
        
        // 1. Загружаем свежие данные с сервера
        await loadDataFromFirebase();
        
        // 2. Применяем ожидающие изменения
        if (window.applyPendingChanges) {
            await applyPendingChanges();
        }
        
        // 3. Очищаем очередь изменений
        localStorageManager.clearPendingChanges(currentUser.uid);
        
        // 4. Сохраняем время синхронизации
        localStorageManager.saveLocalData(currentUser.uid, 'last_sync', new Date().toISOString());
        
        hideLoading();
        showAlert('Синхронизация завершена успешно');
        
    } catch (error) {
        hideLoading();
        console.error('Ошибка синхронизации:', error);
        showAlert('Ошибка синхронизации: ' + error.message);
    } finally {
        if (syncBtn) {
            syncBtn.disabled = false;
            syncBtn.innerHTML = originalHtml;
        }
    }
}

// Создаем модальное окно синхронизации
function createSyncModal() {
    // Проверяем, не создано ли уже окно
    if (document.getElementById('syncModal')) {
        return;
    }
    
    const modalHTML = `
        <div id="syncModal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 400px;">
                <h2>Синхронизация</h2>
                <div id="syncStatus" style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 4px;">
                    <i class="fas fa-spinner fa-spin"></i> Синхронизация...
                </div>
                <div class="modal-actions">
                    <button onclick="closeSyncModal()" class="btn-secondary">Закрыть</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeSyncModal() {
    const modal = document.getElementById('syncModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

function openSyncModal() {
    const modal = document.getElementById('syncModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

// Инициализируем модальное окно при загрузке
document.addEventListener('DOMContentLoaded', () => {
    createSyncModal();
});

// Экспорт функций
window.performManualSync = performManualSync;
window.initSyncModule = initSyncModule;
window.closeSyncModal = closeSyncModal;
window.openSyncModal = openSyncModal;// Модуль работы с тегами
function initTagsModule() {
    console.log('Модуль тегов инициализирован');
}

// Открыть модальное окно тегов
function openTagsModal() {
    renderTagsGrid();
    document.getElementById('tagsModal').style.display = 'flex';
}

// Закрыть модальное окно тегов
function closeTagsModal() {
    document.getElementById('tagsModal').style.display = 'none';
}

// Открыть модальное окно добавления тега
function openAddTagModal() {
    // ЗАПОМИНАЕМ, что окно тегов было открыто
    window.wasTagsModalOpen = document.getElementById('tagsModal').style.display === 'flex';
    
    document.getElementById('tagsModal').style.display = 'none';
    document.getElementById('addTagModal').style.display = 'flex';
}

// Закрыть модальное окно добавления тега
function closeAddTagModal() {
    document.getElementById('addTagModal').style.display = 'none';
    document.getElementById('newTagName').value = '';
    
    // ВОЗВРАЩАЕМСЯ в окно тегов если оно было открыто
    if (window.wasTagsModalOpen) {
        document.getElementById('tagsModal').style.display = 'flex';
        // ОБНОВЛЯЕМ список тегов
        renderTagsGrid();
    }
    
    // Очищаем флаг
    window.wasTagsModalOpen = false;
}

// Добавить новый тег
async function addNewTag() {
    const state = window.appState;
    const selectedColor = state.getSelectedColor();
    
    const name = document.getElementById('newTagName').value.trim();
    
    if (!name) {
        showAlert('Введите название тега');
        return;
    }
    
    if (name.length > 20) {
        showAlert('Название тега не должно превышать 20 символов');
        return;
    }
    
    try {
        const tagData = {
            name: name,
            color: selectedColor
        };
        
        showLoading();
        
        // Сохраняем локально
        const tagId = await addTagLocally(tagData);
        
        // Сразу обновляем UI в окне тегов
        if (window.wasTagsModalOpen) {
            // Обновляем сетку тегов в реальном времени
            addTagToGridUI(tagData, tagId);
        }
        
        // Обновляем список тегов в окне заметки если оно открыто
        if (document.getElementById('noteModal') && 
            document.getElementById('noteModal').style.display === 'flex') {
            if (window.renderAvailableTags) {
                renderAvailableTags();
            }
        }
        
        // Обновляем счетчики
        if (window.updateUserCounters) {
            await updateUserCounters();
        }
        
        hideLoading();
        closeAddTagModal();
        showAlert('Тег создан');
        
    } catch (error) {
        hideLoading();
        console.error('Ошибка создания тега:', error);
        showAlert('Ошибка создания тега: ' + error.message);
    }
}

// Добавить тег в UI сетки (без полной перерисовки)
function addTagToGridUI(tagData, tagId) {
    const container = document.getElementById('tagsList');
    if (!container) return;
    
    // Создаем элемент тега
    const tagElement = document.createElement('div');
    tagElement.className = 'tag-chip';
    tagElement.style.background = tagData.color;
    tagElement.id = `tag-${tagId}`;
    
    const tagName = document.createElement('div');
    tagName.className = 'tag-chip-name';
    tagName.textContent = tagData.name;
    
    const tagUsage = document.createElement('div');
    tagUsage.className = 'tag-chip-usage';
    tagUsage.textContent = 'Используется в 0 заметках';
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'tag-chip-delete';
    deleteBtn.title = 'Удалить тег';
    deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
    
    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        showDeleteTagConfirm(tagId, tagData.name);
    });
    
    tagElement.addEventListener('click', (e) => {
        if (e.target !== deleteBtn && !deleteBtn.contains(e.target)) {
            filterByTagFromModal(tagData.name);
        }
    });
    
    tagElement.appendChild(tagName);
    tagElement.appendChild(tagUsage);
    tagElement.appendChild(deleteBtn);
    
    // Добавляем в начало списка
    if (container.firstChild) {
        container.insertBefore(tagElement, container.firstChild);
    } else {
        container.appendChild(tagElement);
    }
    
    // Удаляем сообщение "Нет тегов" если оно есть
    const noTagsMessage = container.querySelector('div[style*="grid-column: 1 / -1"]');
    if (noTagsMessage) {
        noTagsMessage.remove();
    }
}

// Рендеринг сетки тегов (полная перерисовка)
function renderTagsGrid() {
    const state = window.appState;
    const container = document.getElementById('tagsList');
    const allTags = state.getAllTags();
    
    if (!container) return;
    
    // Если тегов нет, показываем сообщение
    if (allTags.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #999; padding: 48px;">Нет созданных тегов</div>';
        return;
    }
    
    container.innerHTML = '';
    
    // Сортируем теги по имени
    const sortedTags = [...allTags].sort((a, b) => a.name.localeCompare(b.name));
    
    sortedTags.forEach(tag => {
        const tagElement = document.createElement('div');
        tagElement.className = 'tag-chip';
        tagElement.style.background = tag.color;
        
        const tagName = document.createElement('div');
        tagName.className = 'tag-chip-name';
        tagName.textContent = tag.name;
        
        const tagUsage = document.createElement('div');
        tagUsage.className = 'tag-chip-usage';
        tagUsage.textContent = `Используется в ${tag.usageCount || 0} заметках`;
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'tag-chip-delete';
        deleteBtn.title = 'Удалить тег';
        deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
        
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            showDeleteTagConfirm(tag.id, tag.name);
        });
        
        tagElement.addEventListener('click', (e) => {
            if (e.target !== deleteBtn && !deleteBtn.contains(e.target)) {
                filterByTagFromModal(tag.name);
            }
        });
        
        tagElement.appendChild(tagName);
        tagElement.appendChild(tagUsage);
        tagElement.appendChild(deleteBtn);
        container.appendChild(tagElement);
    });
}

// Показать подтверждение удаления тега
function showDeleteTagConfirm(tagId, tagName) {
    showConfirm('Удалить этот тег?', () => deleteTag(tagId, tagName));
}

// Удалить тег
async function deleteTag(tagId, tagName) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!tagId || !currentUser) return;
    
    try {
        showLoading();
        
        // Удаляем локально
        await deleteTagLocally(tagId);
        
        // Удаляем из UI если окно тегов открыто
        if (document.getElementById('tagsModal') && 
            document.getElementById('tagsModal').style.display === 'flex') {
            removeTagFromGridUI(tagId);
        }
        
        hideLoading();
        showAlert(`Тег "${tagName}" удален`);
        
    } catch (error) {
        hideLoading();
        console.error('Ошибка удаления тега:', error);
        showAlert('Ошибка удаления тега: ' + error.message);
    }
}

// Удалить тег из UI сетки
function removeTagFromGridUI(tagId) {
    const tagElement = document.querySelector(`#tag-${tagId}`);
    if (tagElement) {
        tagElement.remove();
    }
    
    // Проверяем, остались ли теги
    const container = document.getElementById('tagsList');
    if (container && container.children.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #999; padding: 48px;">Нет созданных тегов</div>';
    }
}

// Удалить тег локально
async function deleteTagLocally(tagId) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return;
    
    // Загружаем текущие теги
    const localTags = localStorageManager.loadLocalData(currentUser.uid, 'tags') || [];
    const updatedTags = localTags.filter(tag => tag.id !== tagId);
    
    // Сохраняем локально
    localStorageManager.saveLocalData(currentUser.uid, 'tags', updatedTags);
    
    // Обновляем глобальное состояние
    state.setAllTags(updatedTags);
    
    // Добавляем в очередь синхронизации
    if (window.isOnline && isOnline) {
        // Если онлайн, пытаемся сразу удалить из Firebase
        if (window.deleteTagFromFirebase) {
            await deleteTagFromFirebase(tagId);
        }
    } else {
        // Если офлайн, добавляем в очередь
        localStorageManager.addPendingChange(currentUser.uid, {
            type: 'DELETE_TAG',
            data: { id: tagId },
            timestamp: new Date().toISOString()
        });
    }
    
    // Обновляем UI везде где нужно
    updateAllTagUIs();
}

// Добавить тег локально
// В функции addTagLocally:
async function addTagLocally(tagData) {
    const state = window.appState;
    const currentUser = state.getCurrentUser();
    
    if (!currentUser) return null;
    
    // Загружаем текущие теги
    const localTags = localStorageManager.loadLocalData(currentUser.uid, 'tags') || [];
    
    // Проверяем на дубликат
    const existingTag = localTags.find(tag => tag.name.toLowerCase() === tagData.name.toLowerCase());
    if (existingTag) {
        throw new Error('Тег с таким названием уже существует');
    }
    
    // Создаем тег с временным ID
    const tagId = `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const newTag = {
        ...tagData,
        id: tagId,
        createdAt: new Date(), // Используем Date объект
        isLocal: true,
        usageCount: 0
    };
    
    // Добавляем в локальное хранилище с помощью менеджера
    localTags.push(newTag);
    localStorageManager.saveLocalData(currentUser.uid, 'tags', localTags);
    
    // Обновляем глобальное состояние
    state.setAllTags(localTags);
    
    // Синхронизируем с Firebase если онлайн
    if (window.isOnline && isOnline) {
        if (window.syncTagToFirebase) {
            await syncTagToFirebase(tagData, tagId, false);
        }
    } else {
        // Добавляем в очередь синхронизации
        localStorageManager.addPendingChange(currentUser.uid, {
            type: 'CREATE_TAG',
            data: { ...tagData, id: tagId },
            timestamp: new Date().toISOString()
        });
    }
    
    return tagId;
}

// Обновить все UI связанные с тегами
function updateAllTagUIs() {
    // Обновляем сетку тегов если открыто окно тегов
    if (document.getElementById('tagsModal') && 
        document.getElementById('tagsModal').style.display === 'flex') {
        renderTagsGrid();
    }
    
    // Обновляем список тегов если открыто окно заметки
    if (document.getElementById('noteModal') && 
        document.getElementById('noteModal').style.display === 'flex') {
        if (window.renderAvailableTags) {
            renderAvailableTags();
        }
    }
}

// Фильтрация по тегу из модального окна
function filterByTagFromModal(tagName) {
    filterByTag(tagName);
    closeTagsModal();
}

// Фильтр по тегу
function filterByTag(tagName) {
    const state = window.appState;
    const allTags = state.getAllTags();
    
    state.setCurrentFilterTag(tagName);
    
    const tag = allTags.find(t => t.name === tagName);
    const tagColor = tag ? tag.color : '#666';
    
    const activeFilter = document.getElementById('activeFilter');
    const filterTag = document.getElementById('filterTag');
    
    if (activeFilter && filterTag) {
        activeFilter.style.display = 'flex';
        filterTag.textContent = tagName;
        filterTag.style.background = tagColor;
    }
    
    // Применяем фильтр
    if (window.applyCurrentFilter) {
        applyCurrentFilter();
    }
}

// Очистить фильтр
function clearFilter() {
    const state = window.appState;
    
    state.setCurrentFilterTag(null);
    
    const activeFilter = document.getElementById('activeFilter');
    if (activeFilter) {
        activeFilter.style.display = 'none';
    }
    
    // Применяем фильтр (показывает все)
    if (window.applyCurrentFilter) {
        applyCurrentFilter();
    }
}

// Обновление UI тегов (устаревшая функция, оставлена для совместимости)
function updateTagsUI() {
    updateAllTagUIs();
}

// Экспорт функций
window.openTagsModal = openTagsModal;
window.closeTagsModal = closeTagsModal;
window.openAddTagModal = openAddTagModal;
window.closeAddTagModal = closeAddTagModal;
window.addNewTag = addNewTag;
window.filterByTag = filterByTag;
window.clearFilter = clearFilter;
window.filterByTagFromModal = filterByTagFromModal;
window.showDeleteTagConfirm = showDeleteTagConfirm;
window.renderTagsGrid = renderTagsGrid;
window.updateTagsUI = updateTagsUI;
window.deleteTagLocally = deleteTagLocally;
window.addTagLocally = addTagLocally;
window.addTagToGridUI = addTagToGridUI;
window.removeTagFromGridUI = removeTagFromGridUI;
window.updateAllTagUIs = updateAllTagUIs;// Модуль UI и попапов
function initUIModule() {
    console.log('Модуль UI инициализирован');
}

// Аватар
function stringToColor(string) {
            let hash = 0;
            for (let i = 0; i < string.length; i++) {
                hash = string.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Используем только насыщенные цвета (убираем слишком светлые и темные)
            const hue = hash % 360;
            const saturation = 70 + (hash % 30); // 70-100%
            const lightness = 50 + (hash % 20);  // 50-70%
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        
        function generateAvatar(email) {
            const firstLetter = email.charAt(0).toUpperCase();
            const color = stringToColor(email);
            
            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.style.backgroundColor = color;
            avatar.textContent = firstLetter;
            
            return avatar;
        }

// Система попапов
let confirmCallback = null;

// Показать попап подтверждения
function showConfirm(message, callback) {
    console.log('Показываем подтверждение:', message);
    document.getElementById('popupMessage').textContent = message;
    document.getElementById('confirmPopup').style.display = 'flex';
    confirmCallback = callback;
}

// Обработчик кнопки "Да"
function confirmYes() {
    console.log('Нажата кнопка "Да"');
    
    if (confirmCallback) {
        console.log('Выполняем колбэк...');
        try {
            confirmCallback();
            console.log('Колбэк выполнен успешно');
        } catch (error) {
            console.error('Ошибка в колбэке:', error);
        }
    }
    
    document.getElementById('confirmPopup').style.display = 'none';
    confirmCallback = null;
}

// Обработчик кнопки "Нет"
function confirmNo() {
    console.log('Нажата кнопка "Нет"');
    document.getElementById('confirmPopup').style.display = 'none';
    confirmCallback = null;
}

// Показать попап уведомления
function showAlert(message) {
    console.log('Показываем уведомление:', message);
    document.getElementById('alertMessage').textContent = message;
    document.getElementById('alertPopup').style.display = 'flex';
}

// Скрыть попап уведомления
function closeAlert() {
    document.getElementById('alertPopup').style.display = 'none';
}

// Открытие модального окна
function openModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
    }
}

// Закрыть модальное окно
function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
}

// Закрыть все модальные окна
function closeAllModals() {
    ['authModal', 'noteModal', 'tagsModal', 'addTagModal', 'confirmPopup', 'alertPopup']
        .forEach(modalId => closeModal(modalId));
}

// Показать загрузку
function showLoading() {
    document.getElementById('loading').style.display = 'flex';
}

// Скрыть загрузку
function hideLoading() {
    document.getElementById('loading').style.display = 'none';
}

// Показать сообщение авторизации
function showAuthMessage(message, type) {
    const el = document.getElementById('authMessage');
    el.textContent = message;
    el.className = type === 'success' ? 'message-success' : 'message-error';
}

// Экспорт функций
window.showConfirm = showConfirm;
window.confirmYes = confirmYes;
window.confirmNo = confirmNo;
window.showAlert = showAlert;
window.closeAlert = closeAlert;
window.closeModal = closeModal;
window.closeAllModals = closeAllModals;
window.showLoading = showLoading;
window.hideLoading = hideLoading;
window.showAuthMessage = showAuthMessage;// Вспомогательные функции

// Форматирование даты (обрабатывает все типы)
function formatDate(timestamp) {
    if (!timestamp) return '';
    
    let date;
    
    try {
        // Если это Firebase Timestamp объект
        if (timestamp.toDate && typeof timestamp.toDate === 'function') {
            date = timestamp.toDate();
        }
        // Если это объект с seconds и nanoseconds
        else if (timestamp.seconds !== undefined) {
            date = new Date(timestamp.seconds * 1000);
            if (timestamp.nanoseconds) {
                date.setMilliseconds(date.getMilliseconds() + timestamp.nanoseconds / 1000000);
            }
        }
        // Если это строка даты
        else if (typeof timestamp === 'string') {
            date = new Date(timestamp);
        }
        // Если это Date объект
        else if (timestamp instanceof Date) {
            date = timestamp;
        }
        // Если это число (timestamp в миллисекундах)
        else if (typeof timestamp === 'number') {
            date = new Date(timestamp);
        }
        else {
            console.warn('Неизвестный формат даты:', timestamp);
            return '';
        }
        
        // Проверяем валидность даты
        if (isNaN(date.getTime())) {
            console.warn('Невалидная дата:', timestamp);
            return '';
        }
        
        const now = new Date();
        const diffMs = now - date;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        
        if (diffDays === 0) {
            return `Сегодня в ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        } else if (diffDays === 1) {
            return `Вчера в ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        } else if (diffDays < 7) {
            return `${diffDays} дн. назад`;
        } else {
            return date.toLocaleDateString('ru-RU', {
                day: 'numeric',
                month: 'short',
                year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
            });
        }
        
    } catch (error) {
        console.error('Ошибка форматирования даты:', error, timestamp);
        return '';
    }
}

// Функция для получения цвета тега по умолчанию
function getDefaultTagColor(tagName) {
    let hash = 0;
    for (let i = 0; i < tagName.length; i++) {
        hash = tagName.charCodeAt(i) + ((hash << 5) - hash);
    }
    
    const colors = [
        '#FF6B6B', '#4ECDC4', '#FFD166', '#06D6A0',
        '#118AB2', '#073B4C', '#7209B7', '#F72585',
        '#FF9F1C', '#2A9D8F', '#E76F51', '#264653'
    ];
    
    return colors[Math.abs(hash) % colors.length];
}

// Рендеринг заметок (полностью защищенная)
function renderNotes(notesData) {
    const container = document.getElementById('notesContainer');
    if (!container) {
        console.error('Контейнер заметок не найден');
        return;
    }
    
    try {
        // Получаем теги из состояния с защитой
        const state = window.appState;
        let allTags = [];
        
        if (state && typeof state.getAllTags === 'function') {
            allTags = state.getAllTags();
        }
        
        // ГАРАНТИРУЕМ, что allTags - массив
        if (!Array.isArray(allTags)) {
            console.warn('renderNotes: allTags не является массивом, исправляем:', allTags);
            allTags = [];
        }
        
        // Преобразуем notesData в массив
        let notes = convertToArray(notesData);
        console.log('renderNotes: получено заметок:', notes.length);
        
        // Если нет заметок, показываем соответствующее сообщение
        if (notes.length === 0) {
            const state = window.appState;
            const filterTag = state ? state.getCurrentFilterTag() : null;
            
            container.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; color: #999; padding: 48px;">
                    ${filterTag ? 
                        'Нет заметок с этим тегом' : 
                        'Нет заметок. Создайте первую!'}
                </div>
            `;
            return;
        }
        
        // Рендерим заметки
        const notesHtml = notes.map((note, index) => {
            try {
                // Проверяем каждую заметку
                if (!note || typeof note !== 'object') {
                    console.warn(`renderNotes: пропускаем некорректную заметку ${index}:`, note);
                    return '';
                }
                
                // Получаем теги заметки
                const noteTags = getNoteTags(note, allTags);
                
                // Получаем оценку
                const rating = getNoteRating(note);
                const ratingClass = `rating-${rating}`;
                
                // Форматируем дату
                const formattedDate = formatDate(note.updatedAt || note.createdAt);
                
                // Экранируем текст
                const title = escapeHtml(note.title || 'Без названия');
                const body = note.body ? truncateText(note.body, 100) : '';
                const subbody = note.subbody ? truncateText(note.subbody, 100) : '';
                const notesText = note.notes ? truncateText(note.notes, 100) : '';
                
                // Генерируем HTML для тегов
                const tagsHtml = noteTags.length > 0 ? `
                    <div class="note-tags">
                        ${noteTags.map(tag => `
                            <button class="tag" 
                                    onclick="event.stopPropagation(); filterByTag('${escapeHtml(tag.name)}')"
                                    style="background: ${tag.color}">
                                ${escapeHtml(tag.name)}
                            </button>
                        `).join('')}
                    </div>
                ` : '';
                
                // Генерируем HTML для оценки
                const ratingHtml = rating > 0 ? `
                    <div class="note-rating-display">
                        <span style="font-weight: bold; color: #666;">Оценка: ${rating}/5</span>
                    </div>
                ` : '';
                
                // Генерируем HTML для заметки
                return `
                    <div class="note-card" onclick="openNoteModal(${JSON.stringify(note).replace(/"/g, '&quot;')})">
                        <div class="note-rating-indicator ${ratingClass}"></div>
                        <div class="note-header">
                            <div class="note-title">${title}</div>
                        </div>
                        ${body ? `<div class="note-text">${body}</div>` : ''}
                        ${subbody ? `<div class="note-text">${subbody}</div>` : ''}
                        ${notesText ? `<div class="note-text">${notesText}</div>` : ''}
                        ${tagsHtml}
                        ${ratingHtml}
                        <div class="note-date">${formattedDate}</div>
                    </div>
                `;
                
            } catch (error) {
                console.error(`renderNotes: ошибка рендеринга заметки ${index}:`, error);
                return '';
            }
        }).join('');
        
        container.innerHTML = notesHtml;
        
    } catch (error) {
        console.error('Критическая ошибка в renderNotes:', error);
        container.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; color: #f44336; padding: 48px;">
                <i class="fas fa-exclamation-triangle"></i><br>
                Критическая ошибка отображения заметок<br>
                <small>${error.message}</small>
            </div>
        `;
    }
}

// Вспомогательные функции для renderNotes
function convertToArray(data) {
    if (!data) return [];
    
    if (Array.isArray(data)) {
        return data.filter(item => item && typeof item === 'object');
    }
    
    if (typeof data === 'object') {
        // Если это объект с массивом notes
        if (data.notes && Array.isArray(data.notes)) {
            return data.notes.filter(item => item && typeof item === 'object');
        }
        // Если это объект с массивом data
        else if (data.data && Array.isArray(data.data)) {
            return data.data.filter(item => item && typeof item === 'object');
        }
        // Если это объект, где ключи - ID
        else {
            return Object.values(data).filter(item => item && typeof item === 'object');
        }
    }
    
    return [];
}

function getNoteTags(note, allTags) {
    if (!note.tagsArray || !Array.isArray(note.tagsArray)) {
        return [];
    }
    
    // ГАРАНТИРУЕМ, что allTags - массив
    const safeAllTags = Array.isArray(allTags) ? allTags : [];
    
    return note.tagsArray.map(tagName => {
        const tag = safeAllTags.find(t => t && t.name === tagName);
        return {
            name: tagName,
            color: tag && tag.color ? tag.color : getDefaultTagColor(tagName)
        };
    }).filter(tag => tag.name); // Фильтруем пустые теги
}

function getNoteRating(note) {
    if (typeof note.rating === 'number') {
        return Math.max(0, Math.min(5, note.rating)); // Ограничиваем 0-5
    }
    return 0;
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function truncateText(text, maxLength) {
    if (!text) return '';
    if (text.length <= maxLength) return escapeHtml(text);
    return escapeHtml(text.substring(0, maxLength)) + '...';
}

// Функция для применения текущего фильтра (новая версия)
function applyCurrentFilterSafe() {
    try {
        const state = window.appState;
        if (!state || !state.getCurrentUser) {
            console.error('applyCurrentFilterSafe: состояние не инициализировано');
            return;
        }
        
        const currentUser = state.getCurrentUser();
        if (!currentUser) return;
        
        // Загружаем заметки
        const localNotes = localStorageManager.loadLocalData(currentUser.uid, 'notes');
        const notesArray = convertToArray(localNotes);
        
        // Применяем фильтр
        const filterTag = state.getCurrentFilterTag();
        let filteredNotes = notesArray;
        
        if (filterTag && filterTag.trim() !== '') {
            filteredNotes = notesArray.filter(note => 
                note && note.tagsArray && Array.isArray(note.tagsArray) && note.tagsArray.includes(filterTag)
            );
        }
        
        // Рендерим
        renderNotes(filteredNotes);
        
    } catch (error) {
        console.error('Ошибка в applyCurrentFilterSafe:', error);
        showErrorNotesState(error.message);
    }
}

// Показ ошибки
function showErrorNotesState(message) {
    const container = document.getElementById('notesContainer');
    if (container) {
        container.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; color: #f44336; padding: 48px;">
                <i class="fas fa-exclamation-triangle"></i><br>
                Ошибка загрузки заметок<br>
                <small>${message}</small>
            </div>
        `;
    }
}

// Экспорт функций
window.formatDate = formatDate;
window.getDefaultTagColor = getDefaultTagColor;
window.renderNotes = renderNotes;
window.applyCurrentFilter = applyCurrentFilter;
window.escapeHtml = (text) => {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
};<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Notes</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <style>
        /* Инлайн стили для немедленного применения */
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
        }
        
        /* Гарантируем, что загрузка будет скрыта если JS не сработал */
        #loading {
            display: none !important;
        }
        
        #loading.visible {
            display: flex !important;
        }
        
        /* Стили для аватарки */
        .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: white;
            margin-right: 12px;
        }
        
        /* Базовые стили кнопок */
        .btn-primary {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
	<!-- Состояние загрузки - изначально скрыто -->
    <div id="loading" class="hidden">
        <div class="spinner"></div>
        <div style="margin-top: 20px; color: #666;">Загрузка приложения...</div>
    </div>
    <!-- Хедер -->
    <header id="header" style="display: none;">
        <div class="user-info">
            <div id="avatarContainer"></div>
            <span id="userEmail"></span>
            <div class="header-actions">
                <button id="settingsBtn" class="btn btn-icon" aria-label="Настройки">
                    <i class="fas fa-gear"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Основной контент -->
    <main id="main" style="display: none;">
        <div class="controls">
            <button onclick="openNoteModal()" class="btn-primary">
                <i class="fas fa-plus"></i> Новая заметка
            </button>
            <div class="controls-right">
                <div id="activeFilter" class="active-filter" style="display: none;">
                    <span id="filterTag" class="tag-badge"></span>
                    <button onclick="clearFilter()" class="btn-clear">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <button onclick="openTagsModal()" class="btn-secondary" title="Управление тегами">
                    <i class="fas fa-tags"></i>
                </button>
                <!-- Кнопка синхронизации будет добавлена скриптом -->
            </div>
        </div>
        <div id="notesContainer" class="notes-grid"></div>
    </main>

    <!-- Модальное окно авторизации -->
    <div id="authModal" class="modal" style="display: none;" onclick="closeModalOnOutsideClick(event, 'authModal')">
        <div class="modal-content">
            <h2>Вход в систему</h2>
            <div class="form-group">
                <input type="email" id="email" placeholder="Email" autocomplete="email">
            </div>
            <div class="form-group">
                <input type="password" id="password" placeholder="Пароль" autocomplete="current-password">
            </div>
            <div class="modal-actions">
                <button onclick="signIn()" class="btn-primary">Войти</button>
                <button onclick="signUp()" class="btn-secondary">Регистрация</button>
            </div>
            <div id="authMessage"></div>
        </div>
    </div>

    <!-- Модальное окно заметки -->
    <div id="noteModal" class="modal" style="display: none;" onclick="closeModalOnOutsideClick(event, 'noteModal')">
        <div class="modal-content">
            <h2 id="modalTitle">Новая заметка</h2>
            <div class="form-group">
                <input type="text" id="modalNoteTitle" placeholder="Заголовок" maxlength="200">
            </div>
            <div class="form-group">
                <input type="text" id="modalNoteBody" placeholder="Текст" maxlength="200">
            </div>
            <div class="form-group">
                <input type="text" id="modalNoteSubbody" placeholder="Дополнительный текст" maxlength="200">
            </div>
            <div class="form-group">
                <textarea type="text" id="modalNoteNotes" placeholder="Заметки"  rows="8"></textarea>
            </div>
			
			<div class="form-group">
				<label>Оценка заметки</label>
				<div id="ratingSelector" class="rating-selector">
					<!-- Опции будут добавлены динамически -->
				</div>
			</div>
            
            <div class="form-group">
                <label>Теги</label>
                <div id="availableTags" class="tags-selector">
                    <!-- Теги будут загружены динамически -->
                </div>
            </div>
            
            <div class="modal-actions">
                <button onclick="saveNote()" id="saveNoteBtn" class="btn-primary">Сохранить</button>
                <button onclick="closeNoteModal()" class="btn-secondary">Отмена</button>
                <button onclick="showDeleteNoteConfirm()" id="deleteNoteBtn" class="btn-danger" style="display: none;">
                    Удалить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно управления тегами (только список) -->
    <div id="tagsModal" class="modal" style="display: none;" onclick="closeModalOnOutsideClick(event, 'tagsModal')">
        <div class="modal-content">
            <div class="modal-header">
                <button onclick="openAddTagModal()" class="btn-primary btn-icon" title="Добавить тег">
                    <i class="fas fa-plus"></i>
                </button>
                <button onclick="closeTagsModal()" class="btn-secondary btn-icon" title="Закрыть">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div id="tagsList" class="tags-grid">
                <!-- Список тегов будет загружен динамически -->
            </div>
        </div>
    </div>

    <!-- Модальное окно добавления тега -->
    <div id="addTagModal" class="modal" style="display: none;" onclick="closeModalOnOutsideClick(event, 'addTagModal')">
        <div class="modal-content">
            <h2>Добавить тег</h2>
            
            <div class="form-group">
                <input type="text" id="newTagName" placeholder="Название тега" maxlength="20">
            </div>
            
            <div class="form-group">
                <label>Цвет тега</label>
                <div class="color-picker">
                    <div class="color-options">
                        <div class="color-option" data-color="#FF6B6B" style="background: #FF6B6B;"></div>
                        <div class="color-option" data-color="#4ECDC4" style="background: #4ECDC4;"></div>
                        <div class="color-option" data-color="#FFD166" style="background: #FFD166;"></div>
                        <div class="color-option" data-color="#06D6A0" style="background: #06D6A0;"></div>
                        <div class="color-option" data-color="#118AB2" style="background: #118AB2;"></div>
                        <div class="color-option" data-color="#073B4C" style="background: #073B4C;"></div>
                        <div class="color-option" data-color="#7209B7" style="background: #7209B7;"></div>
                        <div class="color-option" data-color="#F72585" style="background: #F72585;"></div>
                        <div class="color-option" data-color="#FF9F1C" style="background: #FF9F1C;"></div>
                        <div class="color-option" data-color="#2A9D8F" style="background: #2A9D8F;"></div>
                        <div class="color-option" data-color="#E76F51" style="background: #E76F51;"></div>
                        <div class="color-option" data-color="#264653" style="background: #264653;"></div>
                    </div>
                </div>
            </div>
            
            <div class="modal-actions">
                <button onclick="addNewTag()" class="btn-primary">Добавить</button>
                <button onclick="closeAddTagModal()" class="btn-secondary">Отмена</button>
            </div>
        </div>
    </div>
	
	<!-- Модальное окно импорта -->
    <div id="importModal" class="modal" style="display: none;" onclick="closeModalOnOutsideClick(event, 'importModal')">
        <div class="modal-content">
            <h2>Импорт заметок</h2>
            
            <div class="form-group">
                <label>Выберите JSON файл с заметками</label>
                <input type="file" id="importFile" accept=".json" style="padding: 0; border: none;">
                <div class="file-info" id="fileInfo" style="display: none; margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px;">
                    <div id="fileName"></div>
                    <div id="fileSize"></div>
                </div>
            </div>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="importOverwrite" checked>
                    Заменить существующие заметки с одинаковыми ID
                </label>
            </div>
            
            <div id="importPreview" class="import-preview" style="display: none;">
                <h3>Предпросмотр (первые 3 заметки):</h3>
                <div id="previewContent"></div>
                <div id="totalNotes" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
            </div>
            
            <div id="importStatus" class="import-status" style="display: none; margin: 15px 0; padding: 10px; border-radius: 4px;"></div>
            
            <div class="modal-actions">
                <button onclick="processImport()" id="importBtn" class="btn-primary" disabled>
                    <i class="fas fa-upload"></i> Импортировать
                </button>
                <button onclick="closeImportModal()" class="btn-secondary">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно экспорта -->
    <div id="exportModal" class="modal" style="display: none;" onclick="closeModalOnOutsideClick(event, 'exportModal')">
        <div class="modal-content">
            <h2>Экспорт заметок</h2>
            
            <div class="form-group">
                <label>Выберите формат экспорта</label>
                <select id="exportFormat" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="json">JSON (полный)</option>
                    <option value="json_min">JSON (минимизированный)</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>Параметры экспорта</label>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <label>
                        <input type="checkbox" id="exportWithTags" checked>
                        Включать теги
                    </label>
                    <label>
                        <input type="checkbox" id="exportTimestamps" checked>
                        Включать даты создания/обновления
                    </label>
                </div>
            </div>
            
            <div id="exportStats" class="export-stats" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                <h3>Статистика</h3>
                <div>Всего заметок: <span id="exportTotalNotesCount">0</span></div>
                <div>Заметок с тегами: <span id="exportNotesWithTags">0</span></div>
                <div>Всего тегов: <span id="exportTotalTagsCount">0</span></div>
            </div>
            
            <div id="exportStatus" class="export-status" style="display: none; margin: 15px 0; padding: 10px; border-radius: 4px;"></div>
            
            <div class="modal-actions">
                <button onclick="exportNotes()" class="btn-primary">
                    <i class="fas fa-download"></i> Экспортировать
                </button>
                <button onclick="closeExportModal()" class="btn-secondary">Отмена</button>
            </div>
        </div>
    </div>
	
	<!-- Модальное окно настроек -->
	<div id="settingsModal" class="modal" style="display: none;" onclick="closeModalOnOutsideClick(event, 'settingsModal')">
	  <div class="modal-content">
		<div class="modal-header">
			<div id="avatarContainerOptions"></div>
			<span id="userEmailOptions"></span>
                <button onclick="signOut()" title="Выйти" class="logout-btn">
                    <i class="fas fa-sign-out-alt"></i>
                </button>
		  <button class="close-btn" data-modal-id="settingsModal">
			<i class="fas fa-times"></i>
		  </button>
		  
		</div>
		
		<div class="modal-body">
			<!-- Кнопки импорта/экспорта -->
				<div>
                <button onclick="showExportNotes()" class="btn-icon" title="Экспорт заметок">
                    <i class="fas fa-download"></i>
                </button>
                <button onclick="showImportNotes()" class="btn-icon" title="Импорт заметок">
                    <i class="fas fa-upload"></i>
                </button>
				</div>
		  <!-- Статистика -->
		  <div class="settings-section">
			<h3>Статистика</h3>
			<div class="statistics">
			  <div class="stat-item">
				<span class="stat-label">Всего заметок:</span>
				<span id="settingsTotalNotesCount" class="stat-value">0</span>
			  </div>
			  <div class="stat-item">
				<span class="stat-label">Тегов:</span>
				<span id="settingsTotalTagsCount" class="stat-value">0</span>
			  </div>
			</div>
		  </div>
		  
		  <!-- Настройки отображения -->
		  <div class="settings-section">
			<h3>Настройки отображения</h3>
			<div class="form-group">
			  <label for="cardsPerSessionSelect">
				Количество карточек за сессию:
			  </label>
			  <select id="cardsPerSessionSelect" class="form-select">
				<option value="10">10 карточек</option>
				<option value="20">20 карточек</option>
				<option value="30">30 карточек</option>
			  </select>
			</div>
		  </div>
		</div>
		
		<div class="modal-footer">
		  <button id="saveSettingsBtn" class="btn btn-primary">
			Сохранить
		  </button>
		  <button class="btn btn-secondary" data-modal-id="settingsModal">
			Отмена
		  </button>
		</div>
	  </div>
	</div>

    <!-- Попап подтверждения -->
    <div id="confirmPopup" class="popup" style="display: none;">
		<div class="popup-content">
			<div class="popup-message" id="popupMessage"></div>
			<div class="popup-actions">
				<button onclick="confirmYes()" class="btn-primary">Да</button>
				<button onclick="confirmNo()" class="btn-secondary">Нет</button>
			</div>
		</div>
	</div>

    <!-- Попап уведомления -->
    <div id="alertPopup" class="popup" style="display: none;">
        <div class="popup-content">
            <div class="popup-message" id="alertMessage"></div>
            <div class="popup-actions">
                <button onclick="closeAlert()" class="btn-primary">OK</button>
            </div>
        </div>
    </div>

    <!-- Состояние загрузки -->
    <div id="loading" class="loading">
        <div class="spinner"></div>
    </div>

    <!-- Подключаем файлы -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    
    <script src="firebase-config.js"></script>
    <script src="local-storage.js"></script>
    <script src="app.js"></script>
    <script src="auth.js"></script>
    <script src="notes.js"></script>
    <script src="tags.js"></script>
    <script src="ui.js"></script>
    <script src="utils.js"></script>
    <script src="import-export.js"></script>
    <script src="settings.js"></script>
    <script src="sync.js"></script>
    
     <script>
        // ЭКСТРЕННЫЙ СКРИПТ - гарантированно показывает интерфейс
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM полностью загружен');
            
            // 1. Немедленно показываем body
            document.body.style.visibility = 'visible';
            document.body.style.opacity = '1';
            
            // 2. Проверяем Firebase
            if (typeof firebase === 'undefined') {
                console.error('Firebase не загружен');
                showAuthModalDirect();
                return;
            }
            
            // 3. Показываем загрузку на короткое время
            const loading = document.getElementById('loading');
            if (loading) {
                loading.style.display = 'flex';
                loading.classList.remove('hidden');
            }
            
            // 4. Аварийный таймаут - через 3 секунды показываем форму авторизации
            setTimeout(function() {
                const authModal = document.getElementById('authModal');
                const mainApp = document.getElementById('main');
                
                if (loading) {
                    loading.style.display = 'none';
                    loading.classList.add('hidden');
                }
                
                // Если приложение не показалось, показываем форму авторизации
                if (!mainApp || mainApp.style.display === 'none') {
                    console.log('Аварийный показ формы авторизации');
                    showAuthModalDirect();
                }
            }, 3000);
        });
        
        // Прямой показ формы авторизации
        function showAuthModalDirect() {
            const authModal = document.getElementById('authModal');
            const loading = document.getElementById('loading');
            
            if (loading) {
                loading.style.display = 'none';
                loading.classList.add('hidden');
            }
            
            if (authModal) {
                authModal.style.display = 'flex';
            }
            
            // Показываем сообщение если есть
            const authMessage = document.getElementById('authMessage');
            if (authMessage) {
                authMessage.textContent = 'Пожалуйста, войдите в систему';
                authMessage.style.display = 'block';
            }
        }
        
        // Экспортируем для глобального доступа
        window.showAuthModalDirect = showAuthModalDirect;
    </script>
</body>
</html>